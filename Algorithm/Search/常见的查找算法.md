# 查找算法
> 在查找表中只做查找操作，而不改动表中数据元素，称此类查找表为静态查找表；反之，在查找表中做查找操作的同时进行插入数据或者删除数据的操作，称此类表为动态查找表。
>
> 动态查找表中做查找操作时，若查找成功可以对其进行删除；如果查找失败，即表中无该关键字，可以将该关键字插入到表中。

## 顺序查找
> 从表中的最后一个数据元素开始，逐个同记录的关键字做比较，如果匹配成功，则查找成功；反之，如果直到表中第一个关键字查找完也没有成功匹配，则查找失败。类似于遍历；

## 二分查找
> 折半查找，也称二分查找;该算法的使用的前提是静态查找表中的数据必须是有序的。
>
> 若查找表中存储的数据元素含有多个关键字时，使用哪种关键字做折半查找，就需要提前以该关键字对所有数据进行排序。

## 二叉排序数(二叉查找树)
> 如果二叉树不为空，则具有如下特点：
> - 二叉排序树中，如果其根结点有左子树，那么左子树上所有结点的值都小于根结点的值；
> - 二叉排序树中，如果其根结点有右子树，那么右子树上所有结点的值都大于根结点的值；
> - 二叉排序树的左右子树也要求都是二叉排序树；
>
> 二叉排序树本身是动态查找表的一种表示形式，有时会在查找过程中插入或者删除表中元素，当因为查找失败而需要插入数据元素时，该数据元素的插入位置一定位于二叉排序树的叶子结点，并且一定是查找失败时访问的最后一个结点的左孩子或者右孩子
>
> 一个无序序列可以通过构建一棵二叉排序树，从而变成一个有序序列。
>
> 使用二叉排序树在查找表中做查找操作的时间复杂度同建立的二叉树本身的结构有关。

#### 插入
> 查找失败插入数据时，一定是查找失败时访问的最后一个结点的左孩子或者右孩子。

#### 删除
> 如果在使用二叉排序树表示的动态查找表中删除某个数据元素时，需要在成功删除该结点的同时，依旧使这棵树为二叉排序树。
> - 结点 p 为叶子结点，此时只需要删除该结点，并修改其双亲结点的指针即可；
> - 结点 p 只有左子树或者只有右子树，此时只需要将其左子树或者右子树直接变为结点 p 双亲结点的左子树即可；
> - 结点 p 左右子树都有，此时有两种处理方式：
>> - 令结点 p 的左子树为其双亲结点的左子树；结点 p 的右子树为其自身直接前驱结点的右子树
![第一种处理方式](http://data.biancheng.net/uploads/allimg/171016/2-1G016152R32b.png)
>> - 用结点 p 的直接前驱（或直接后继）来代替结点 p，同时在二叉排序树中对其直接前驱（或直接后继）做删除操作。
![第二种处理方式](http://data.biancheng.net/uploads/allimg/171016/2-1G016152T5W2.png)
## 平衡二叉树
> 平衡二叉树，又称为 AVL 树。实际上就是遵循以下两个特点的二叉树：
> - 每棵子树中的左子树和右子树的深度差不能超过 1；
> - 二叉树中每棵子树都要求是平衡二叉树；
>
> 平衡因子：每个结点都有其各自的平衡因子，表示的就是其左子树深度同右子树深度的差。平衡二叉树中各结点平衡因子的取值只可能是：0、1 和 -1。

#### 二叉排序数到平衡二叉树的转换
> 在不会破坏二叉排序树本身结构的前提下，将二叉排序树转化为平衡二叉树。

## 参考列表
- [查找算法](http://data.biancheng.net/search/)

