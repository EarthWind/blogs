# 多进程
#### 理论
> **进程和线程区别**：
> - 地址空间和其他资源：进程间相互独立，同一进程的各个线程间共享；不同进程的线程相互不可见；
> - 通信：进程IPC(管道PIPE、命名管道FIFO、消息队列MessageQueue、共享存储SharedMemory、信号量Semaphore、套接字Socket、信号Signal);线程一般使用全局变量和锁进行通信
> - 调度和切换：线程的上下文切换比进程的上下文切换要快很多
> - 多线程OS中，进程不是一个可执行实体(没懂)

> **孤儿进程**
>> 父进程退出了，子进程还在；父进程在退出时，会遍历所有进程，将其子进程的父进程ppid设为1 init进程；

> **僵尸进程**
>> 子进程退出了，但是父进程没有调用wait或waitpid收集它的返回值，在这种情况下系统无法判断父进程是否还需要这些信息，导致子进程处于一个特殊状态，这种进程叫僵尸进程；僵尸进程会占用宝贵的PID资源，如果不及时清理会导致无法创建进程；处理僵尸进程的方法是杀掉其父进程，使其成为孤儿进程，init调用wait回收其返回值；可以使用命令`ps -ef | grep defunct`查看僵尸进程；可以使用命令`cat /proc/sys/kernel/pid_max`查看进程的最大数量；可以通过命令`cat /proc/process-pid/limits`查看进程的资源限制；

> **进程状态**

| 序号 | 状态 | 缩写 | 含义 |
| ---- | ---- | ---- | ---- |
| 1 | TASK_RUNNING | R | 在在运行或在队列中等待调度 |
| 2 | TASK_INTERRUPTIBLE | S | 可中断的休眠 |
| 3 | TASK_UNINTERRUPTIBLE | D | 不可中断的休眠 |
| 4 | __TASK_STOPPED | T | 停止状态，进程接收到SIGSTOP等信号时 |
| 5 | __TASK_TRACED | t | 跟踪状态，比如被debugger的ptrace() |
| 6 | EXIT_ZOMBIE | Z | 僵尸状态，即父进程没有执行waitpid或wait |
| 7 | EXIT_DEAD | X | 死亡状态 |


#### 进程创建
> - ` pid_t fork(void);`
>> `#include <sys/types.h>`
>>
>> `#include <unistd.h>`
>>
>> 描述：创建一个子进程，返回两个值，如果创建成功，子进程返回0，父进程返回子进程的进程ID；如果创建失败，父进程返回-1，没有子进程；
>>
>> man 7 [参考](http://man7.org/linux/man-pages/man2/fork.2.html)
>>
>> note: 子进程和父进程的变量的虚拟地址空间是一样的，但是物理空间不一样，两个进程对变量的修改互不影响；

> - `pid_t vfork(void);`
>> `#include <sys/types.h>`
>>
>> `#include <unistd.h>`
>>
>> 描述：创建一个子进程，创建共享资源的进程；和fork有以下两个区别：
>> - `vfork`创建子进程时和父进程内存数据共享，`fork`会复制(写时复制)父进程的数据空间，堆和栈；
>> - `vfork`保证子进程先与父进程调度执行，子进程在调用`exit`或`exec`后父进程再执行，而fork并没有相应的执行顺序；
>>
>> man 7 [参考](http://man7.org/linux/man-pages/man2/fork.2.html)

> - `int clone(int (*fn)(void *), void *child_stack, int flags, void *arg, .../* pid_t *ptid, void *newtls, pid_t *ctid */ );`
>> `#define _GNU_SOURCE`
>>
>> `#include <sched.h>`
>>
>> 描述： 和fork相似的方式创建一个新进程，是对系统调用sys_fork的封装
>>
>> fn: 指向子程序需要运行测程序，即“剧本”
>>
>> child_stack: 为子进程分配堆栈空间
>>
>> flags: 用于标记从父进程获取那些资源
>>
>> arg : 传递给fn的参数
>>
>> man 7 [参考](http://man7.org/linux/man-pages/man2/clone.2.html)

#### 进程回收
> - `pid_t wait(int *wstatus);`
>>
>> `#include <sys/types.h>`
>>
>> `#include <sys/wait.h>`
>> 
>> 描述： 等待任意的子进程退出并捕获退出状态，如果子进程的状态已经盖面，则立即返回，否则，要么阻塞等待到一个子进程的状态变化，要么使用信号进行终止；
>>
>> wstatus: 保存子进程返回的状态
>>
>> 返回：成功-返回子进程的pid，失败-返回-1
>>
>> man 7 [参考](http://man7.org/linux/man-pages/man2/waitpid.2.html)

> - `pid_t waitpid(pid_t pid, int *stat_loc, int options);`
>> `#include <sys/wait.h>`
>>
>> 描述：等待指定的进程退出；并捕获子进程退出状态；
>>
>> pid: >0-指定等待的子进程，=0-等待和调度进程同一组ID下的任意子进程，=-1-任意子进程，同wait一致；-1>-等待进程组ID等于pid绝对值的所有子进程；
>>
>> stat_loc: 进程返回的状态
>>
>> options: WNOHANG-如果没有子进程终止就立即返回；WUNTRACED-如果一个子进程stoped且没有被traced，那么立即返回；WCONTINUED-如果stoped的子进程童工SIGCONT重新运行，那么立即返回；

> - `int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);`
>> `#include <sys/wait.h>`
>> 
>> 描述：可以用指定要等待退出的进程或进程组；
>>
>> idtype: P_PID-id指定的类型为进程id，表示要等待指定的进程；P_PGID-id指定为进程组id,表示等待进程组中任意进程退出；P_ALL-等待任意进程退出，忽略id
>>
>> id：根据idtype的值含义不同
>>
>> infop: 指向引起进程变化的信号的详细信息
>> 
>> options: 表示关注的状态变化；WCONTINUED-一个stoped的进程又重新被继续；WEXITED-等待已退出的进程；WNOHANG-如果没有可用的子进程退出状态，立即返回而非阻塞；WNOWAIT-不破坏子进程的退出状态，又后续的wait、waitid或waitpid调用取得；WSTOPPED-等待一个进程，它已经暂停

#### exec系列函数
> exec函数簇是用新的进程空间替换现在的进程空间，但pid不变，还是以前的pid；调用exec后，系统会申请一块新的进程空间来存放被调用的程序，然后当前的进程携带pid跳转到新的进程空间，并从main函数开始执行，旧的进程空间被回收；exec系列函数只有在错误的时候才返回，返回值为-1，并且errno被设置；vfork和exec结合使用时，就不存在数据的复制，所以其创建进程的速度很快；

> - `int execl(const char *path, const char *arg0, ... /*, (char *)0 */);`
> - `int execle(const char *path, const char *arg0, ... /*,(char *)0, char *const envp[]*/);`
> - `int execlp(const char *file, const char *arg, ... /* (char  *) NULL */);`
> - `int execv(const char *path, char *const argv[]);`
> - `int execve(const char *path, char *const argv[]);`
> - `int execvp(const char *file, char *const argv[],char *const envp[]);`
>> man 7 [参考](http://man7.org/linux/man-pages/man3/exec.3.html)

> 该函数簇分为两大类
>> - execl: 参数argv是可变参数形式，`const char *arg0, const char *arg1,`
>> - execv: 参数argv为字符串数组的形式
>>
> 又分为三小类
>> - 不带后缀：新进程继承旧进程的环境变量，进程的环境变量在变量`extren char **environ`中
>> - 带后缀e: 新进程不继承旧进程的环境变量
>> - 带后缀p: 在环境变量中搜索可执行文件，不需要指定绝对路径

#### 进程的退出
> 正常退出
>> - 从`main()`返回
>> - 调用`exit()`、`_exit()`、`_Exit()`， 退出状态为传入这些函数的参数
>> - 最后一个线程从启动例程返回
>> - 最后一个线程调用`pthread_exit()`
>>
>> 正常退出时内核会将退出状态转变为终止状态以供父进程`wait()`、`waitpid()`等函数获取
>
> 异常退出
>> - 调用`abort()`
>> - 接收到终止`信号`
>> - 最后一个线程被取消
>>
>> 异常退出时内核也会用一个指示其异常终止原因的终止状态来表示进程，也可以又父进程的`wait()`、`waitpid()`等函数捕获；
>
> `exit()`、`_exit()`和`_Exit()`区别：
>> - `exit()`和`_Exit()`头文件为stdlib.h
>> - `_exit()`头文件为unistd.h
>> - `exit()`是系统调用级别的，用于运行过程中随时结束；`return`是语言级别的，是调用堆栈返回，返回上一级调用；
>> - `exit()`会调用终止处理程序和用户空间的标准IO清理程序，而`_exit()`、`_Exit()`不会调用而是又内核管理清理

#### 进程终止清理程序
> - `int atexit(void (*function)(void));`
>> `#include <stdlib.h>`
>>
>> 描述：在调用exit()或在main函数return时会调用通过该方式注册的函数，调用的顺序和注册的顺序相反，类似栈先入后出的结构
>>
>> function: 注册的函数指针
>>
>> 返回：0-注册成功，其他-注册失败
>>
>>注意：
>> - 同一个函数可以注册多次，但只会被调用一次
>> - 异常退出的时通过atexit或on_exit注册的函数是不会被调用的，比如通过调用abort()函数的调用；
>> - 并且注册的函数没有携带参数
>> - 在注册的函数中禁止使用exit相关的调用，不然会造成无限递归
>> - 在注册函数中调用`longjmp`会导致结果未定义
>> - 调用fork创建子进程时，子进程会继承所有父进程注册的函数，一旦调用exec函数成功后，所有的注册函数都会被清除;
>>
>> man 7 [参考](http://man7.org/linux/man-pages/man3/atexit.3.html)

> - `int on_exit(void (*function)(int , void *), void *arg);`
>> `#include <stdlib.h>`
>>
>> 描述：进程在调用exit()或从main函数返回时这种正常退出时会调用通过on_exit注册的清理函数；
>>
>> function: 注册的函数
>>
>> arg: 注册函数的参数
>>
>> 返回：0-注册成功，其他-注册失败
>>
>> note: 为了兼容新，尽量避免使用该函数，最好使用标准的atexit函数注册终止清理函数

#### daemon守护进程



#### 参考列表
- [c语言 - 多进程编程](https://www.zfl9.com/c-multi-proc.html)
- [进程间通信的方式——信号、管道、消息队列、共享内存](https://www.cnblogs.com/LUO77/p/5816326.html)
- [Linux进程管理(一)](http://gityuan.com/2017/07/30/linux-process/)
- [进程控制之waitid函数](https://www.bbsmax.com/A/A2dmZZ1xze/)


#### 案列
> - fork_example.c
```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv[]){
        int n = 0;
        printf("before fork: n = %d\n", n);

        pid_t pid = fork();
        if(pid < 0){
                perror("fork error");
                exit(EXIT_FAILURE);
        }else if(pid == 0){
                n++;
                printf("child_proc(%d, ppid=%d): n = %d\n", getpid(), getppid(), n);
        }else{
                n--;
                printf("parent_proc(%d): n = %d\n", getpid(), n);
        }

        printf("quit_proc(%d) ...\n", getpid());

        return 0;
}

```

> - vfork_example.c
```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>


int main(int argc, char *argv[]){
        int var = 11;

        pid_t pid = vfork();
        if(pid < 0){
                perror("vfork error.");
        }else if(pid == 0){
                printf("child_proc start running.\n");
                var++;
                printf("var : %d\n", var);
                printf("child_proc is going to exit.\n");
                exit(0);
        }

        printf("var : %d\n", var);

        return 0;
}
```

- ateixt_example.c
```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

static void bye();

int main(int argc, char *argv[]){
        long a;
        int i;

        a = sysconf(_SC_ATEXIT_MAX);
        printf("ATEXIT_MAX = %ld\n", a);

        i = atexit((void *)&bye);
        if(i != 0){
                fprintf(stderr, "cann't register exit function\n");
                exit(EXIT_FAILURE);
        }

        exit(EXIT_SUCCESS);
}

static void bye(){
        printf("That was all, folks\n");
}
```

