# GCC
> -E: 只进行预处理，不编译，ASSIC标准输出；-C告诉预处理器不丢弃注释，-P告诉预处理器不产生#inline，这两个选项都和-E一起使用
>
> -S: 只编译，不汇编，生成.s文件
>
> -c: 编译，汇编，不链接
>
> -o: 指定输出文件的名称，包括预处理文件、汇编文件以及可执行文件的生成
>
> -I: 指定include包含文件的搜索目录
>
> -L dir: 指定链接目录
>
> -l library: 指定链接的动态库名称
>
> -static: gcc链接时默认使用系统中的动态链接库，加上该参数后不使用动态链接而使用静态链接
>
> -g: 添加调试信息，可用于多种包含gdb的调试器，等级可以为g1，g2，g3,默认为g2
>
> -ggdb: 添加gdb调试使用的信息，调试等级为ggdb1,ggdb2,ggdb3,默认为ggdb2
>
> -v: 输出编译过程所采用的每一个选项
>
> -ansi: ANSI标准
>
> -std=gnu89/c99/gnu99
>
> -w: 忽略所有警告
>
> -W: 打印一些额外的警告信息
>
> -Werror: 不区分警告和错误，遇到警告就停止编译
>
> -Wall: 开启大部分警告
>
> -Wextra: 对所有合法但值值得怀疑的表达式发出警告
>
> -Wshadow: 局部变量和全局变量重名时发出警告
>
> -O0: 关闭所有编译器优化
>
> -O1: 第一级优化，使文件更小，运行更快，简写为-O
>
> -O2: 第二级优化，采用所有优化技术
>
> -O3: 第三级优化，在O2的基础山增加了inline函数、寄存器等优化技术
>
> -O5: 类似于O2，但只优化存储空间，不会优化性能
>
> -shared: 生成动态链接库
>
> -x: 更换源文件的后缀名

# GDB
> 一般在编译过程中使用-g参数或-ggdb后可以使用gdb调试
```SHELL
gdb object_file_name
gdb object_file_core_name # core 是core dump产生的文件，可以通过ulimit -c设置core文件的最大值
gdb PID # PID为程序运行的进程号
```
> -r: 运行程序
>
> -c: 继续运行程序，直到下一个断点处
>
> -b: 设置断点
>> b <行号>
>>
>> b <函数名称>
>>
>> b *<函数名称> # 停在编译器生成的prolog代码处，主要用于汇编调试
>>
>> b *<代码地址> # 停在代码地址处
>>
>> d <编号> # 删除断点
>>
>> info b # 查看设置的断点
>
> s: 执行一行源码，如果有函数调用，则进入函数
>
> n: 执行一行源码，如果有函数调用，则此函数调用执行完成
>
> si: 针对汇编指令执行一行代码
>
> ni: 针对汇编指令执行一行代码
>
> p: 打印指定的变量、字符串、表达式的值
>
> display: 设置中断后想显示的数据及其格式
>
> undisplay <编号>: 取消先前的display设置
>
> i(info): 显示各类信息
> 
> l: 列出源码
> 
> ptype: 显示变量的类型
>
> return: 强制从当前函数返回
>
> watch: 监视一个变量的值
>
> whatis: 显示变量的值和类型
>
> clear: 删除一个断点
>
> bt: 显示堆栈信息
>
> finish: 继续执行直到函数返回
>
> load: 动态加载一个可执行文件


#### Linux动态链接库的搜索路径和顺序
- 使用gcc命令的-L选项
- 通过LD_LIBRARY_PATH环境变量进行指定
- 在/etc/ld.so.conf文件添加路径或在/etc/ld.so.d/filename.conf文件添加路径
- 默认搜索路径为/lib,/lib64,/usr/lib,/usr/lib64


####  参考
[GCC编译选项与GDB调试学习总结](https://blog.csdn.net/yzhang6_10/article/details/78076659)



