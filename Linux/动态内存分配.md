# 内存分配函数
- `void *malloc(size_t size);`

  > #include <stdlib.h>或#include <malloc.h>

  > 用于动态分配连续的内存空间，分配的大小为size字节数，当内存不再使用时需要调用free()进行释放；可参考[这里](http://blog.codinglabs.org/articles/a-malloc-tutorial.html)如何实现一个malloc函数，内存空间分配完成后，需要调用memset函数进行内存空间的初始化；
  >
  > - size: 分配的内存大小字节数
  >
  > 返回：成功-返回指向内存的指针；失败-返回NULL，注意在size=0时成功也会返回NULL；
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man3/free.3.html)


- `void *calloc (size_t __nmemb, size_t __size);`

  > #include <stdlib.h> 或 #include <malloc.h>

  > 分配\__nmemb个大小为\__size的连续内存空间，并将每一个字节都初始化为0；分配成功则返回相应的指针，分配失败则返回NULL,分配的内存空间的大小为\__nmemb * \__size个字节,需要进行手动的free；和malloc函数的区别是colloc分配空间以后会将分配的空间自动初始化为0，但malloc不会对分配的内存空间初始化； 

- `void *memalign (size_t __alignment, size_t __size);`

  > #include <malloc.h>

  > 用于分配大粒度的内存块；该函数返回一个由\__size指定大小，地址是\__alignment的倍数的内存块，其中\__alignment必须是2的幂；

- `void * valloc (size_t size); `

  > #include <malloc.h>

  > 用于分配大粒度的内存块，内部实现为memalign(getpagesize(), size)，该函数分配的块大小为系统配置的页大小；

- `void *alloca(size_t size);`

  > #include <alloca.h>

  > 返回size个字节的空间，在栈上分配空间，而不像其他的内存分配函数在堆上分配空间，这种分配方式称为动态分配，该函数分配的空间会不需要释放，也不存在释放函数，如果使用该函数分配大空间有可能导致栈溢出；

- `void *realloc(void *ptr, size_t size);`

  > #include<stdlib.h>

  >


- `void *memset(void *s, int c, size_t n);`

  > #include <string.h>

  > 初始化s指针指向的后那个字节的内容为c

- `void *memcpy(void *dest, const void *src, size_t n);`

  > #include <string.h>

  > 复制src地址的n字节数据到dest,注意复制时内存区域不能重叠，如果重叠，可以使用memmove()函数;返回指向dest的指针，参考[这里](http://man7.org/linux/man-pages/man3/memcpy.3.html)

- `void *memmove(void *dest, const void *src, size_t n);`

  > #include <string.h>

  > 复制src地址的n字节数据到dest,复制时可能会发送内存区域重叠；

- 


#### 内存中堆和栈得区别
> - 管理方式不同：栈是由编译器自动管理，由alloca动态分配的栈空间也会自动释放；堆是由库函数提供，程序员需要进行手动地分配释放内存
> - 空间大小不同：栈的大小会存在大小限制，linux系统可以用`ulimit -a`查看stack size栈大小，程序超过栈大小就会产生溢出，使用`ulimit -s`或在文件`/etc/security/limits.conf`中进行设置；堆没有大小的限制；
> - 能否产生碎片：大量的malloc和和free操作会使得堆更容易产生碎片；
> - 生长方式不同：栈的生长方向是向下的，也就是说往小地址的方向分配内存；堆的生长方向是向上的；
> - 分配效率不同：栈是机器系统提供的数据结构，计算机底层提供了相应的支持，分配专用的寄存器存放栈地址，压栈和出栈也有专用的指令，所以栈的分配效率高；而堆在分配时会按照一定的算法进行查找回收分配；
> - 分配方式不同：栈有静态分配和动态分配，静态分配由编译器完成，动态分配可调用alloca函数进行分配，由编译器释放；堆只有动态分配方式；

参考[这里](https://www.cnblogs.com/JCSU/articles/1051579.html)
