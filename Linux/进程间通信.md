# 进程间通信(IPC)
> **常用的通信方式**
> - 匿名管道(pipe)
> - 命名管道(fifo)
> - 消息队列(messagequeue)
> - 共享内存(sharedmemory)
> - 信号量(semaphore)
> - 套接字(socket)
> - 信号(signal)

#### 匿名管道(pipe)
> 管道是由内核管理的一个缓冲区，一般被设计成环形的数据结构，可以看成一个循环队列，这样以便管道被循环利用；管道的一端连接一个进程的输出，进程会向管道种写入信息，管道的另一端连接另一个进程的输入，它会从管道种读取信息，管道空，则读取进程阻塞等待数据被写入，管道满，则写入进程阻塞等待数据被读取；当最后一个进程关闭对它的引用时，pipe会自动撤销；可以参考[man 7](http://man7.org/linux/man-pages/man7/pipe.7.html)

> **特点**
> - 管道是半双工的，数据只能向一个方向流动，即只支持单向数据流，双方都需要通信时，需要建立起两个管道
> - 只能用于有亲属(父子进程或兄弟进程)关系的进程之间进行通信
> - 构成独立的运行于内存的文件系统(管道不是普通的文件，但相对于进程来说，管道就是一个文件)
> - 承载无格式字节流
> - 缓冲区大小受限(PIPE_BUF)
> - 无名字标识

**创建**
- `int pipe(int pipefd[2]);`
  > `#include <unistd.h>`
  >
  > 描述：创建一个管道，pipefd[0]代表读端，pipefd[1]代表写端
  >
  > pipefd: 用于保存生成的管道描述符,pipefd[0]代表读端，pipefd[1]代表写端
  >
  > 返回： 成功-返回0；失败-返回-1，并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/pipe.2.html)

- `int pipe2(int pipefd[2], int flags);`
  > `#define _GNU_SOURCE`
  >
  > `#include <fcntl.h>`
  >
  > `#include <unistd.h>`
  >
  > 描述：和`pipe`一样用于创建管道，当flags=0时和pipe函数一样；
  >
  > pipefd: 用于保存生成的管道描述符,pipefd[0]代表读端，pipefd[1]代表写端
  >
  > flags: 用于设置管道特性：
  > - 0: 不设置管道的特性，则pipe2函数和pipe函数一致
  > - O_CLOEXEC: 如果设置该标志位，则在子进程fork+exec后会原子操作该类文件描述符，和open打开文件描述符特性一致
  > - O_DIRECT: 将IO模式设置为包模式，每个write操作写入的数据都是被看作是一个独立的包，如果写入的数据的字节长度多余PIPE_BUF(`getconf -a | grep PIPE`或`ulimit -p`，linux的PIPE_BUF一般为4096 bytes)字节的数据会被自动切分成多个包发送，PIPE_BUF和写入字节会影响阻塞情况下write的原子操作特性；并且read操作设置该属性后一次读取一个包，读取的size小于包的大小会读取size个字节，包中多余的数据字节将会被丢弃，所以一般将read的size设置为PIPE_BUF，这样就保证能够都去出完整的一个包数据；
  > - O_NONBLOCK: 设置该管道符的操作为非阻塞模式，默认为阻塞模式
  >
  > 返回： 成功-返回0；失败-返回-1，并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/pipe.2.html)

#### 命名管道(FIFO)
> 匿名管道没有名字，只能在亲缘进程间通信；而有名管道就是为了克服这个缺点，有名在系统上提供了一个路径名，以文件形式存在于系统中，这样，即使于有名管道的创建进程不存在的亲缘关系的进程，只要可以访问该文件，就能够彼此通信；有名管道严格遵循先进先出的规则，对它的读总是从开始处返回数据，对它的写则是把数据添加到末尾，有名管道不支持lseek等文件定位操作；虽然有名管道已文件形式存在系统中，但写入其的内容存储在内存中，不占用任何的磁盘空间，操作的时候也需要两段同时操作，否则默认就阻塞；参考[这里](http://man7.org/linux/man-pages/man7/fifo.7.html)

> **特点**
> - 单向数据流，半双工模式，同时需要通信时需要创建两个有名管道
> - 以文件形式出现中系统中
> - 内容存储在内存中，不占用磁盘空间
> - 命名管道会一直存在，需要显示地删除
> - 写入原子操作受限(PIPE_BUF)，缓冲区受限
> - 系统内的进程间通信，可以不是有亲属关系的进程

**创建**
- `int mkfifo(const char *pathname, mode_t mode);`
  > `#include <sys/types.h>`
  >
  > `#include <sys/stat.h>`
  >
  > 描述：创建具有指定权限的命名管道，创建成功就可以调用open,read,write,close等函数对命名管道进行操作了；
  >
  > pathname: 管道的文件路径名称
  >
  > mode: 命名管道的权限，会受到进程umask的影响，最终的权限为mode & ~umask, mode可以参考[这里](http://man7.org/linux/man-pages/man2/open.2.html)的O_CREAT部分中的权限，也可以传入`0755`等参数
  >
  > 返回：成功-返回0；失败-返回-1，并设置了errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man3/mkfifo.3.html)

- `int mkfifoat(int dirfd, const char *pathname, mode_t mode);`
  > `#include <fcntl.h>`
  >
  > `#include <sys/stat.h>`
  >
  > 描述：和`mkfifo`函数一样，用于创建一个命名管道，当pathname是绝对路径时，忽略dirfd参数，当pathname时相对路径时，则创建的的命名管道路径不是相对于进程的当前目录，而是相对于dirfd文件描述符，如果dirfd=AT_FDCWD，那么是相对于进程当前目录的；
  >
  > dirfd: 指定用于创建命名管道的描述符
  >
  > pathname: 命名管道路径名
  >
  > mode: 命名管道的权限
  >
  > 返回：成功-返回0；失败-返回-1，并设置了errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man3/mkfifo.3.html)

- `int unlink(const char *pathname);`
  > `#include <unistd.h>`
  >
  > 描述：从文件系统中删除一个名字，如果这个名字是指向文件的最后以连接，并且没有进程打开这个文件时，则删除文件，如果有进程打开文件，则在文件关闭后删除这个文件，释放文件所占用的空间；如果pathname是一个符号连接，则删除连接；可以使用该函数来删除命名管道
  >
  > pathname: 指定要删除的名字
  >
  > 返回：成功-返回0；失败-返回-1并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/unlink.2.html)

- `int unlinkat(int dirfd, const char *pathname, int flags);`
  > `#include <fcntl.h>`
  >
  > `#include <unistd.h>`
  >
  > 描述：和`unlink`函数一样，用于删除文件系统中的一个名字；如果pathname是绝对路径，则忽略dirfd;如果pathname是相对路径，则pathname是相对于dirfd的，而不是先对于进程的当前目录；
  >
  > dirfd: 指定相对路径描述符
  >
  > pathname: 指定要删除的文件描述符
  >
  > flags: 默认为0，如果设置为AT_REMOVEDIR时，表示删除一个目录，相当于rmdir
  >
  > 返回：成功-返回0；失败-返回-1并设置errno;
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/unlink.2.html)

#### 消息队列
> 


#### 参考列表
- [linux系统编程之管道（一）：匿名管道（pipe)](http://www.cnblogs.com/mickole/p/3192210.html)
- [进程间通信的方式——信号、管道、消息队列、共享内存](https://www.cnblogs.com/LUO77/p/5816326.html)
- [linux中的PIPE_SIZE与PIPE_BUF，管道最大写入值问题](https://blog.csdn.net/judwenwen2009/article/details/44134415)
- [Linux中link，unlink，close，fclose详解](https://blog.csdn.net/DLUTBruceZhang/article/details/9159431)
- [【Linux】进程间通信-命名管道FIFO](https://blog.csdn.net/xiajun07061225/article/details/8471777)

#### 案列
- pipe_demon.c
> 源码
```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main(int argc, char *argv[]){
        int pipfd[2], ret;
        pid_t cpid;
        char buf;

        if(argc < 2){
                fprintf(stderr, "Usage: %s mesg...\n", argv[0]);
                exit(EXIT_FAILURE);
        }

        //创建管道
        ret = pipe(pipfd);
        if(ret == -1){
                //perror会先输出char *参数，然后将errno对应的错误描述输出
                perror("pipe error");
                exit(EXIT_FAILURE);
        }

        //创建子进程
        cpid = fork();
        if(cpid == -1){
                perror("fork error");
                exit(EXIT_FAILURE);
        }else if(cpid == 0){
                //关闭不必要的文件描述符，pipfd[1]为写端描述符
                close(pipfd[1]);
                printf("child(%ld) write to STDOUT_FILENO\n", (long)getpid());
                //从管道每次读取一个字符
                while(read(pipfd[0], &buf, 1) > 0){
                        write(STDOUT_FILENO, &buf, 1);
                }
                //输出到标准输出
                write(STDOUT_FILENO, "\n", 1);
                //读完数据后关闭管道读端，当管道的两端描述符都关闭后，管道会自动注销
                close(pipfd[0]);
                exit(EXIT_SUCCESS);
        }else{
                //关闭不必要的文件描述符，pipefd[0]为读端描述符
                close(pipfd[0]);
                //写数据到文件描述符
                write(pipfd[1], argv[1], strlen(argv[1]));
                //写完数据后关闭管道写端
                close(pipfd[1]);
                wait(NULL);
                exit(EXIT_SUCCESS);
        }
}
```

- fifo_daemon
> talker01.c
```C
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>

#define BUF_SIZE 4096

int main(int argc, char *argv[]){
        int ret, i, fifo01fd, fifo02fd;
        char buf[BUF_SIZE];

        for(i = 0; i < BUF_SIZE; i++){
                buf[i] = 0;
        }
        ret = mkfifo("fifo01", 0777);
        if(ret != 0){
                perror("mkfifo fifo01 error");
                exit(EXIT_FAILURE);
        }
        ret = mkfifo("fifo02", 0777);
        if(ret != 0){
                perror("mkfifo fifo02 error");
                exit(EXIT_FAILURE);
        }

        fifo01fd = open("fifo01", O_WRONLY);
        if(fifo01fd == -1){
                perror("open fifo01 error");
                exit(EXIT_FAILURE);
        }
        fifo02fd = open("fifo02", O_RDONLY);
        if(fifo02fd == -1){
                perror("open fifo02 error");
                close(fifo01fd);
                exit(EXIT_FAILURE);
        }

        while(1){
                printf("echo : ");
                fgets(buf, BUF_SIZE, stdin);
                ret = write(fifo01fd, buf, strlen(buf) + 1);
                if(ret == -1){
                        perror("write error");
                        close(fifo01fd);
                        close(fifo02fd);
                        exit(EXIT_FAILURE);
                }
                ret = read(fifo02fd, buf, BUF_SIZE);
                if(ret == -1){
                        perror("read error");
                        close(fifo01fd);
                        close(fifo02fd);
                        exit(EXIT_FAILURE);
                }
                printf("reply: %s", buf);
        }

        exit(EXIT_SUCCESS);
}
```
> talker02.c
```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>

#define BUF_SIZE 1024

int main(int argc, char *argv[]){
        int ret, i, fifo01fd, fifo02fd;
        char buf[BUF_SIZE];

        for(i = 0; i < BUF_SIZE; i++){
                buf[i] = 0;
        }
        fifo01fd = open("fifo01", O_RDONLY);
        if(fifo01fd == -1){
                perror("open fifo01 error");
                exit(EXIT_FAILURE);
        }
        fifo02fd = open("fifo02", O_WRONLY);
        if(fifo02fd == -1){
                perror("open fifo02 error");
                close(fifo01fd);
                exit(EXIT_FAILURE);
        }

        while(1){
                printf("reply: ");
                ret = read(fifo01fd, buf, BUF_SIZE);
                if(ret == -1){
                        perror("read error");
                        close(fifo01fd);
                        close(fifo02fd);
                        exit(EXIT_FAILURE);
                }
                printf("%s", buf);
                printf("echo : ");
                fgets(buf, BUF_SIZE, stdin);
                ret = write(fifo02fd, buf, strlen(buf) + 1);
                if(ret == -1){
                        perror("write error");
                        close(fifo01fd);
                        close(fifo02fd);
                        exit(EXIT_FAILURE);
                }
        }

        exit(EXIT_SUCCESS);
}
```

