# 进程间通信(IPC)
> **常用的通信方式**
> - 匿名管道(pipe)
> - 命名管道(fifo)
> - 消息队列(messagequeue)
> - 共享内存(sharedmemory)
> - 信号量(semaphore)
> - 套接字(socket)
> - 信号(signal)

#### 匿名管道(pipe)
> 管道是由内核管理的一个缓冲区，一般被设计成环形的数据结构，可以看成一个循环队列，这样以便管道被循环利用；管道的一端连接一个进程的输出，进程会向管道种写入信息，管道的另一端连接另一个进程的输入，它会从管道种读取信息，管道空，则读取进程阻塞等待数据被写入，管道满，则写入进程阻塞等待数据被读取；当最后一个进程关闭对它的引用时，pipe会自动撤销；可以参考[man 7](http://man7.org/linux/man-pages/man7/pipe.7.html)

> **特点**
> - 管道是半双工的，数据只能向一个方向流动，即只支持单向数据流，双方都需要通信时，需要建立起两个管道
> - 只能用于有亲属(父子进程或兄弟进程)关系的进程之间进行通信
> - 构成独立的运行于内存的文件系统(管道不是普通的文件，但相对于进程来说，管道就是一个文件)
> - 承载无格式字节流
> - 缓冲区大小受限(PIPE_BUF)
> - 无名字标识

**创建**
- `int pipe(int pipefd[2]);`
  > `#include <unistd.h>`
  >
  > 描述：创建一个管道，pipefd[0]代表读端，pipefd[1]代表写端
  >
  > pipefd: 用于保存生成的管道描述符,pipefd[0]代表读端，pipefd[1]代表写端
  >
  > 返回： 成功-返回0；失败-返回-1，并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/pipe.2.html)

- `int pipe2(int pipefd[2], int flags);`
  > `#define _GNU_SOURCE`
  >
  > `#include <fcntl.h>`
  >
  > `#include <unistd.h>`
  >
  > 描述：和`pipe`一样用于创建管道，当flags=0时和pipe函数一样；
  >
  > pipefd: 用于保存生成的管道描述符,pipefd[0]代表读端，pipefd[1]代表写端
  >
  > flags: 用于设置管道特性：
  > - 0: 不设置管道的特性，则pipe2函数和pipe函数一致
  > - O_CLOEXEC: 如果设置该标志位，则在子进程fork+exec后会原子操作该类文件描述符，和open打开文件描述符特性一致
  > - O_DIRECT: 将IO模式设置为包模式，每个write操作写入的数据都是被看作是一个独立的包，如果写入的数据的字节长度多余PIPE_BUF(`getconf -a | grep PIPE`或`ulimit -p`，linux的PIPE_BUF一般为4096 bytes)字节的数据会被自动切分成多个包发送，PIPE_BUF和写入字节会影响阻塞情况下write的原子操作特性；并且read操作设置该属性后一次读取一个包，读取的size小于包的大小会读取size个字节，包中多余的数据字节将会被丢弃，所以一般将read的size设置为PIPE_BUF，这样就保证能够都去出完整的一个包数据；
  > - O_NONBLOCK: 设置该管道符的操作为非阻塞模式，默认为阻塞模式
  >
  > 返回： 成功-返回0；失败-返回-1，并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/pipe.2.html)

#### 命名管道(FIFO)
> 匿名管道没有名字，只能在亲缘进程间通信；而有名管道就是为了克服这个缺点，有名在系统上提供了一个路径名，以文件形式存在于系统中，这样，即使于有名管道的创建进程不存在的亲缘关系的进程，只要可以访问该文件，就能够彼此通信；有名管道严格遵循先进先出的规则，对它的读总是从开始处返回数据，对它的写则是把数据添加到末尾，有名管道不支持lseek等文件定位操作；虽然有名管道已文件形式存在系统中，但写入其的内容存储在内存中，不占用任何的磁盘空间，操作的时候也需要两段同时操作，否则默认就阻塞；参考[这里](http://man7.org/linux/man-pages/man7/fifo.7.html)

> **特点**
> - 单向数据流，半双工模式，同时需要通信时需要创建两个有名管道
> - 以文件形式出现中系统中
> - 内容存储在内存中，不占用磁盘空间
> - 命名管道会一直存在，需要显示地删除
> - 写入原子操作受限(PIPE_BUF)，缓冲区受限
> - 系统内的进程间通信，可以不是有亲属关系的进程

**创建**
- `int mkfifo(const char *pathname, mode_t mode);`
  > `#include <sys/types.h>`
  >
  > `#include <sys/stat.h>`
  >
  > 描述：创建具有指定权限的命名管道，创建成功就可以调用open,read,write,close等函数对命名管道进行操作了；
  >
  > pathname: 管道的文件路径名称
  >
  > mode: 命名管道的权限，会受到进程umask的影响，最终的权限为mode & ~umask, mode可以参考[这里](http://man7.org/linux/man-pages/man2/open.2.html)的O_CREAT部分中的权限，也可以传入`0755`等参数
  >
  > 返回：成功-返回0；失败-返回-1，并设置了errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man3/mkfifo.3.html)

- `int mkfifoat(int dirfd, const char *pathname, mode_t mode);`
  > `#include <fcntl.h>`
  >
  > `#include <sys/stat.h>`
  >
  > 描述：和`mkfifo`函数一样，用于创建一个命名管道，当pathname是绝对路径时，忽略dirfd参数，当pathname时相对路径时，则创建的的命名管道路径不是相对于进程的当前目录，而是相对于dirfd文件描述符，如果dirfd=AT_FDCWD，那么是相对于进程当前目录的；
  >
  > dirfd: 指定用于创建命名管道的描述符
  >
  > pathname: 命名管道路径名
  >
  > mode: 命名管道的权限
  >
  > 返回：成功-返回0；失败-返回-1，并设置了errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man3/mkfifo.3.html)

- `int unlink(const char *pathname);`
  > `#include <unistd.h>`
  >
  > 描述：从文件系统中删除一个名字，如果这个名字是指向文件的最后以连接，并且没有进程打开这个文件时，则删除文件，如果有进程打开文件，则在文件关闭后删除这个文件，释放文件所占用的空间；如果pathname是一个符号连接，则删除连接；可以使用该函数来删除命名管道
  >
  > pathname: 指定要删除的名字
  >
  > 返回：成功-返回0；失败-返回-1并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/unlink.2.html)

- `int unlinkat(int dirfd, const char *pathname, int flags);`
  > `#include <fcntl.h>`
  >
  > `#include <unistd.h>`
  >
  > 描述：和`unlink`函数一样，用于删除文件系统中的一个名字；如果pathname是绝对路径，则忽略dirfd;如果pathname是相对路径，则pathname是相对于dirfd的，而不是先对于进程的当前目录；
  >
  > dirfd: 指定相对路径描述符
  >
  > pathname: 指定要删除的文件描述符
  >
  > flags: 默认为0，如果设置为AT_REMOVEDIR时，表示删除一个目录，相当于rmdir
  >
  > 返回：成功-返回0；失败-返回-1并设置errno;
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/unlink.2.html)

#### 消息队列
> 消息队列就是一个消息的链表，用户可以向队列中添加信息，也可以从队列中读取消息，每个消息有特定的类型，接收时可以不按顺序接收，也可以根据自定义条件接收特定类型的消息；

> **特点**
> - 基于消息，而管道时基于字节流
> - 用链表实现
> - 每个消息有固定大小，消息大小字节上限为msgmax(`cat /proc/sys/kernel/msgmax`)，队列的最大字节数msgmnb(`cat /proc/sys/kernel/msgmnb`),系统队列上限msgmni(`cat /proc/sys/kernel/msgmni`)

**创建**
- `key_t ftok(const char *pathname, int proj_id);`
  > `#include <sys/types.h>`
  >
  > `#include <sys/ipc.h>`
  >
  > 描述：用指定的文件名称和8位的整形proj_id生成IPC key,所以proj_id的取值范围位1到255，可以用于`msgget`,`semget`和`shmget`函数中
  >
  > pathname: 可以任意指定，不存在权限问题，但是该文件或目录必须存在，ftok会使用到该文件的inode来取一个值
  >
  > proj_id: 可以自己约定，随意取值，在1到255之间
  >
  > 返回：成功-返回key_t;失败-返回-1，并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man3/ftok.3.html)
  >
  > note: 注意key_t用来唯一的表示一个消息队列、信号量或共享内存，相同的pathname和proj_id会得到相同的key_t，但是必须保证多次使用的时候pathname的inode要一致，删除后重新创建的pathname会使得其inode发送变化，所以生成的key_t不一致，所以应当注意；

- `int msgget(key_t key, int msgflg);`
  > `#include <sys/types.h>`
  >
  > `#include <sys/ipc.h>`
  >
  > `#include <sys/msg.h>`
  >
  > 描述：用于生成一个消息队列
  >
  > key: 调用ftok函数生成的IPC key，用于唯一标识一个消息队列
  >
  > msgflag: IPC_CREAT-如果消息队列存在，则返回已经存在的消息队列标识符，如果消息队列不存在，则新创建一个消息都列；IPC_CREAT|IPC_EXCL-消息队列不存在时就创建，存在时返回-1，并设置errno
  >
  > 返回：成功-返回消息队列标识符；失败-返回-1，并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/msgget.2.html)

- `int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);`
  > `#include <sys/types.h>`
  >
  > `#include <sys/ipc.h>`
  >
  > `#include <sys/msg.h>`
  >
  > 描述：添加消息到消息队列中
  >
  > msqid: 指定的消息队列id
  >
  > msgp: 指向消息队列的一个缓冲区，用来存储发送的消息，是一个用户可定义的结构体，如struct msgbuf
  >
  > msgsz: 指定消息的字节大小
  >
  > msgflg: 发送属性设置，常用的标志位为IPC_NOWAIT-设置该位时，如果没有足够的空间添加一个消息，则立即返回而不是阻塞，错误码为EAGAIN
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/msgrcv.2.html)
```C
struct msgbuf {
        long mtype;       /* 消息队列的类型，必须大于0 */
        char mtext[msgsz];    /* 消息队列的数据，是一个字符串数组， 数据大小由msgsz指定*/
};
  ```

- `ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg);`
  > `#include <sys/types.h>`
  >
  > `#include <sys/ipc.h>`
  >
  > `#include <sys/msg.h>`
  >
  > 描述：从消息队列中读取消息
  >
  > msgid: 从指定的消息队列中接收消息
  >
  > msgp: 用来存储接收的消息
  >
  > msgsz: 指定接收消息的大小
  >
  > msgtyp: 指定接收消息的类型，不是该类型的消息会被过滤
  >
  > msgflag: 接收属性配置；IPC_NOWAIT-当消息队列中没有消息时立即返回，errno设置为ENOMSG；MSG_EXCEPT-返回队列中第一个类型不为msgtype的消息；MSG_NOERROR-大于msgsz的消息会被截断，多余的数据会被丢弃
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/msgrcv.2.html)

- `int msgctl(int msqid, int cmd, struct msqid_ds *buf);`
  > `#include <sys/types.h>`
  >
  > `#include <sys/ipc.h>`
  >
  > `#include <sys/msg.h>`
  >
  > 描述：该命令用于操作消息队列
  >
  > msgid: 指定消息队列的id
  >
  > cmd: 指定操作码;`IPC_STAT`-获取消息队列的信息到buf中，`IPC_SET`-通过buf中的值设置消息队列的信息，`IPC_RMID`-立即删除所有消息队列，唤醒所有读写进程，忽略第三个参数，`IPC_INFO`-返回系统队列的所有限制信息到buf中，其结构体为`struct msginfo`,`MSG_INFO`-像IPC_INFO一样返回msginfo结构体，`MSG_STAT`-和IPC_STAT结构体一样，`MSG_STAT_ANY`-和MSG_STAT操作一样，只是不做msg_perm.mode的权限检查(`ls /proc/sysvipc/msg`)，
  >
  > buf: 存储或获取消息属性
  >
  > 返回：成功-IPC_STAT,IPC_SET,IPC_RMID返回0，IPC_INFO或MSG_INFO返回内核数组中使用最多的条目的索引，MSG_STAT和MSG_STAT_ANY操作返回给定的消息队列msqid的标识；失败-返回-1,并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/msgctl.2.html)
```C
struct msqid_ds {
        struct ipc_perm msg_perm;     /* Ownership and permissions */
        time_t          msg_stime;    /* Time of last msgsnd(2) */
        time_t          msg_rtime;    /* Time of last msgrcv(2) */
        time_t          msg_ctime;    /* Time of last change */
        unsigned long   __msg_cbytes; /* Current number of bytes in
                                                queue (nonstandard) */
        msgqnum_t       msg_qnum;     /* Current number of messages
                                                in queue */
        msglen_t        msg_qbytes;   /* Maximum number of bytes
                                                allowed in queue */
        pid_t           msg_lspid;    /* PID of last msgsnd(2) */
        pid_t           msg_lrpid;    /* PID of last msgrcv(2) */
};

struct ipc_perm {
        key_t          __key;       /* Key supplied to msgget(2) */
        uid_t          uid;         /* Effective UID of owner */
        gid_t          gid;         /* Effective GID of owner */
        uid_t          cuid;        /* Effective UID of creator */
        gid_t          cgid;        /* Effective GID of creator */
        unsigned short mode;        /* Permissions */
        unsigned short __seq;       /* Sequence number */
};

struct msginfo {
        int msgpool; /* Size in kibibytes of buffer pool
                        used to hold message data;
                        unused within kernel */
        int msgmap;  /* Maximum number of entries in message
                        map; unused within kernel */
        int msgmax;  /* Maximum number of bytes that can be
                        written in a single message */
        int msgmnb;  /* Maximum number of bytes that can be
                        written to queue; used to initialize
                        msg_qbytes during queue creation
                        (msgget(2)) */
        int msgmni;  /* Maximum number of message queues */
        int msgssz;  /* Message segment size;
                        unused within kernel */
        int msgtql;  /* Maximum number of messages on all queues
                        in system; unused within kernel */
        unsigned short int msgseg;/* Maximum number of segments;
                                unused within kernel */
};
 ```

#### 共享内存
> 共享内存时允许多个不相关的进程访问同一个给定的存储区，这块存储区被两个或两个以上的进程映射到自身的地址空间中，进程之间可以对共享的内存做读写操作来实现进程间通信，它是最有效率的进程间通信方式，因为只需要数据拷贝两次就实现了通信，另外，共享内存不提供同步机制，所以一般对共享内存的使用一般结合其他同步机制如信号量一起使用，另外锁变量机制存在原子性问题，不推荐使用；有两种方式实现共享内存([shm_overview](http://man7.org/linux/man-pages/man7/shm_overview.7.html))：
> - 内存映射：通过mmap系统调用映射一个普通文件实现内存共享，进程就像读写内存一样对普通文件进行操作，不必调用read()，write()等操作
> - 共享内存机制：通过映射特殊文件系统shm中的文件实现进程间的共享内存通信
>
> 提供了两种接口
> - POSIX共享内存(shm_open(), shm_unlink()): 可以在`/dev/shm`中查看到相应的文件
> - System V共享内存(shmget(), shmat(), shmdt())：可以使用`ipcs`命令查看，相应的信息也保存在了/proc/sysvipc/目录下

> **特点**
> - 效率高，值进行两次的数据拷贝
> - 需要额外的同步互斥机制

**函数列表**
- `int shmget(key_t key, size_t size, int shmflg);` 
  > `#include <sys/ipc.h>`
  >
  > `#include <sys/shm.h>`
  >
  > 描述：创建或获取共享内存
  >
  > key: 由ftok函数提供一个key_t给shmget有效地给共享内存命名，如果key为0或IPC_PRIVATE，则会建立新的共享内存
  >
  > size: 以字节为单位指定共享内存的容量，注意内存分配的单位是页，可以通过`getpagesize()`来获取，分配共享内存的容量会是页的整数倍
  >
  > shmflag: 权限标志，可以使用IP_CREAT和mode参数按位或，这样共享内存不存在的时候就可以直接创建；IPC_EXCL-确定共享内存是创建的，如果已经存在，则报错；SHM_HUGETLB-指定在分配共享内存的时候使用大页；SHM_HUGE_2MB,SHM_HUGE_1GB-指定分配的大页大小为2MB或1GB，和SHM_HUGETLB一起使用；SHM_NORESERVE-不为共享内存保留交换空间(?)
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/shmget.2.html)

- `void *shmat(int shmid, const void *shmaddr, int shmflg);`
  > `#include <sys/types.h>`
  >
  > `#include <sys/shm.h>`
  >
  > 描述：将共享内存链接到当前进程的地址空间来启动对共享内存的访问
  >
  > shmid: shmget函数的返回值，标识共享内存
  >
  > shaddr: 一般为NULL，表示由系统自动进行地址的选择
  >
  > shmflag: 通常为0；`SHM_RND`-如果shmaddr被提供了，则连接的地址向下舍入到SHMLBA的倍数；`SHM_EXEC`-允许共享内存内的内容被执行；`SHM_RDONLY`-对共享内存由只读的权限；`SHM_REMAP`-从shmaddr开始拥有共享内存大小空间的需要被重新映射；
  >
  > 返回：成功-返回连接共享内存的指针；失败-返回((void *)-1)，并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/shmat.2.html)

- `int shmdt(const void *shmaddr);`
  > `#include <sys/types.h>`
  >
  > `#include <sys/shm.h>`
  >
  > 描述：取消共享内存和当前进程地址的连接
  >
  > shmaddr: 为shmat返回的地址
  >
  > 返回：成功-返回0；失败-返回-1，并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/shmat.2.html)

- `int shmctl(int shmid, int cmd, struct shmid_ds *buf);`
   > `#include <sys/types.h>`
   >
   > `#include <sys/shm.h>`
   >
   > 描述：控制共享内存
   >
   > shmid: 指定共享内存
   >
   > cmd: 指定对共享内存的操作；`IPC_STAT`-将内核中的共享内存数据结构信息复制到buf中；`IPC_SET`-将buf中的共享内存属性写到内核中去，用于修改共享内存属性；`IPC_RMID`-删除共享内存，忽略第三个参数；`IPC_INFO`-获取系统层面的共享内存限制信息到`struct shminfo`中;`SHM_INFO`-获取共享内存消耗的系统资源信息保存到结构体`struct shm_info`中；`SHM_STAT`,`SHM_STAT_ANY`,`SHM_LOCK`,`SHM_UNLOCK `
   >
   > buf：用于设置或获取共享内存的信息
   >
   > 返回：成功-返回0；失败-返回-1，并设置errno
   >
   > man 7 [参考](http://man7.org/linux/man-pages/man2/shmctl.2.html)
```C
struct shmid_ds {
        struct ipc_perm shm_perm;    /* Ownership and permissions */
        size_t          shm_segsz;   /* Size of segment (bytes) */
        time_t          shm_atime;   /* Last attach time */
        time_t          shm_dtime;   /* Last detach time */
        time_t          shm_ctime;   /* Last change time */
        pid_t           shm_cpid;    /* PID of creator */
        pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */
        shmatt_t        shm_nattch;  /* No. of current attaches */
        ...
};
struct ipc_perm {
        key_t          __key;    /* Key supplied to shmget(2) */
        uid_t          uid;      /* Effective UID of owner */
        gid_t          gid;      /* Effective GID of owner */
        uid_t          cuid;     /* Effective UID of creator */
        gid_t          cgid;     /* Effective GID of creator */
        unsigned short mode;     /* Permissions + SHM_DEST and
                                           SHM_LOCKED flags */
        unsigned short __seq;    /* Sequence number */
};
struct shminfo {
        unsigned long shmmax; /* Maximum segment size */
        unsigned long shmmin; /* Minimum segment size;
                                always 1 */
        unsigned long shmmni; /* Maximum number of segments */
        unsigned long shmseg; /* Maximum number of segments
                                that a process can attach;
                                unused within kernel */
        unsigned long shmall; /* Maximum number of pages of
                                shared memory, system-wide */
};
struct shm_info {
        int           used_ids; /* # of currently existing segments */
        unsigned long shm_tot;  /* Total number of shared memory pages */
        unsigned long shm_rss;  /* # of resident shared memory pages */
        unsigned long shm_swp;  /* # of swapped shared memory pages */
        unsigned long swap_attempts;  /* Unused since Linux 2.4 */
        unsigned long swap_successes;  /* Unused since Linux 2.4 */
};
```

#### 信号量
> 信号量，有时也称作信号灯，是一种用于互斥访问共享资源的机制；信号量只能进行两种操作，即PV操作，P操作会将大于0的信号量减1，V操作会将信号量加1，信号量的PV操作是原子性的([sem_overview](http://man7.org/linux/man-pages/man7/sem_overview.7.html))；

> 两种信号量：
> - 有名信号量：不同进程间的互斥
> - 无名信号量：同一进程内的线程间互斥，如果要用于进程间，则需要和共享内存一起使用；

**函数列表**
- `int semget(key_t key, int nsems, int semflg);`
  > `#include <sys/types.h>`
  >
  > `#include <sys/ipc.h>`
  >
  > `#include <sys/sem.h>`
  >
  > 描述：用于创建或获取一个关联参数key的信号量, 在Linux和POSIX标准中不需要`sys/types.h`和`sys/ipc/h`两个头文件
  >
  > key: 由ftok函数生成，用来生成信号量标识
  >
  > nsems: 创建信号量的数量，一般为1
  >
  > semflg: 和open的参数的权限位，可以结合IPC_CREAT和IPC_EXCL
  >
  > 返回：成功-返回信号量标识；失败-返回-1，并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/semget.2.html)

- `int semop(int semid, struct sembuf *sops, size_t nsops);`
  > `#include <sys/types.h>`
  >
  > `#include <sys/ipc.h>`
  >
  > `#include <sys/sem.h>`
  >
  > 描述：对指定的一个或一组信号量进程操作，sops指定的一组操作是按数组顺序原子操作的
  >
  > semid: 指定的信号量标识
  >
  > sops：指定操作的类型结构体
  >
  > nsops: 指定操作的数量，通常只有一个sops元素，所以一般为1
  >
  > 返回：成功-返回0；失败，返回-1并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/semop.2.html)
```C
struct sembuf{
        unsigned short sem_num;  /* 除非使用一组信号量，不然该值为0 */
        short    sem_op;   /* 如果该值为正，则会添加到信号量的当前值值，如果该值为0，则会阻塞等待信号量变为0，如果该值为负数并且绝对值小于等于信号量的当前值，则信号量会减少，如果绝对值大于信号量的当前值，则会阻塞到能够减少为止，要保证信号量的值不能小于0 */
        short    sem_flg;  /* 有两个选项，IPC_WAIT表示信号操作不满足时不阻塞，而是直接返回，IPC_UNDO表示不管异常或正常退出信号量的值都会被恢复到操作之前的值，保证资源不会被永远锁定 */
}
```

- `int semtimedop(int semid, struct sembuf *sops, size_t nsops, const struct timespec *timeout);`
  > `#include <sys/types.h>`
  >
  > `#include <sys/ipc.h>`
  >
  > `#include <sys/sem.h>`
  >
  > 描述：和semop函数功能一致，只是添加了阻塞超时机制；
  >
  > 返回：成功-返回0；失败，返回-1并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/semop.2.html)

- `int semctl(int semid, int semnum, int cmd, ...);`
  > `#include <sys/types.h>`
  >
  > `#include <sys/ipc.h>`
  >
  > `#include <sys/sem.h>`
  >
  > 描述：用于控制信号量
  >
  > semid: 指定信号量
  >
  > senum：信号量编号，只有使用信号量集的时候才会用到，一般设置为0，就是使用单个信号量
  >
  > cmd: 指定的操作类型，IPC_STAT-获取信号量结构体信息到semun中；IPC_SET-设置信号量的参数；IPC_RMID-立即删除信号量，并且唤醒所有被semop阻塞的进程；IPC_INFO-获取信号量的系统限制信息到semun.buf参数中...
  >
  > ... : 该参数一般为union semun，在某些系统中没有定义的是有需要自己定义
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/semctl.2.html)
```C
union semun {
        int              val;    /* Value for SETVAL */
        struct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */
        unsigned short  *array;  /* Array for GETALL, SETALL */
        struct seminfo  *__buf;  /* Buffer for IPC_INFO(Linux-specific) */
};
struct semid_ds {
        struct ipc_perm sem_perm;  /* Ownership and permissions */
        time_t          sem_otime; /* Last semop time */
        time_t          sem_ctime; /* Last change time */
        unsigned long   sem_nsems; /* No. of semaphores in set */
};
struct ipc_perm {
        key_t          __key; /* Key supplied to semget(2) */
        uid_t          uid;   /* Effective UID of owner */
        gid_t          gid;   /* Effective GID of owner */
        uid_t          cuid;  /* Effective UID of creator */
        gid_t          cgid;  /* Effective GID of creator */
        unsigned short mode;  /* Permissions */
        unsigned short __seq; /* Sequence number */
};
struct  seminfo {
        int semmap;  /* Number of entries in semaphore
                                         map; unused within kernel */
        int semmni;  /* Maximum number of semaphore sets */
        int semmns;  /* Maximum number of semaphores in all
                                         semaphore sets */
        int semmnu;  /* System-wide maximum number of undo
                                         structures; unused within kernel */
        int semmsl;  /* Maximum number of semaphores in a
                                         set */
        int semopm;  /* Maximum number of operations for
                                         semop(2) */
        int semume;  /* Maximum number of undo entries per
                                         process; unused within kernel */
        int semusz;  /* Size of struct sem_undo */
        int semvmx;  /* Maximum semaphore value */
        int semaem;  /* Max. value that can be recorded for
                                         semaphore adjustment (SEM_UNDO) */
};
```

#### 套接字
> 当套接字的协议族为AF_UNIX或AF_LOCAL时，那么套接字就可用来做IPC，可以使用面向流(TCP)和面向数据报(UDP)的接口，并且消息的传递时可靠的，即不会丢失也不会乱序；它和网络套接字的区别是它的地址结构使用sockaddr_un表示，在调用bind的时候需要指定操作系统上的一个socket文件，如果文件存在，则报错，所以在绑定之前需要确定文件不存在([unix](http://man7.org/linux/man-pages/man7/unix.7.html));socketpair还能用于具有亲属关系的进程间进行通信，和pipe内饰，不过它是全双工的的管道；
```C
struct sockaddr_un {
        sa_family_t sun_family;         /* AF_UNIX */
        char        sun_path[108];      /* 指定socket目录文件 */
};
```

> **特点**
> - 不经过网络协议栈
> - 不需要打包拆包
> - 不需要计算校验和
> - 不需要维护序号和应答
>
> **服务器**
> - `int socket(int domain, int type, int protocol); /* domain=AF_LOCAL/AF_UNIX */`
> - `int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen); /* addr=struct sockaddr_un */`
> - `int listen(int sockfd, int backlog);`
> - `int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);`
>
> **客户端**
> - `int socket(int domain, int type, int protocol); /* domain=AF_LOCAL/AF_UNIX */`
> - `int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);`

**函数列表**
- `int socketpair(int domain, int type, int protocol, int sv[2]);`
  > `#include <sys/types.h>`
  >
  > `#include <sys/socket.h>`
  >
  > 描述：用于创建全双工的流管道，用于有亲属关系的进程间通信
  >
  > domain: 指定协议类型， AF_INET, AF_NET6, AF_UNIX(一般使用)
  >
  > type: 指定套接字类型， SOCK_STREAM(一般使用),SOCK_DATAGRAM,SOCK_RAW 
  >
  > protocol: 指定协议，一般为0
  >
  > sv[2]: 生成的两个文件描述符，不区分读写
  >
  > 返回：成功-返回0；失败-返回-1，并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/socketpair.2.html)
  >
  > noet: 在linux上,domain可以是AF_UNIX,AF_LOCAL或AF_TIPC(Linux 4.12)

#### 信号
> [signal - overview of signals](http://man7.org/linux/man-pages/man7/signal.7.html)
>
> 信号是在软件层次对中断机制的一种模拟，信号的处理方式原理上和中断请求可以说是一样的，信号是异步的，主要有硬件和软件两个来源，硬件主要是键盘输入或硬件故障引起，软件主要是调用信号发送函数或一些异常软件操作导致；

> 信号的分类：
>
> 可靠性
>> - 不可靠信号：把建立在早期信号值小于SIGRTMIN(32)的信号叫不可靠信号，其主要有两个问题(1).信号处理完毕后，就会恢复默认的处理方式，所以需要在信号处理完毕后再次调用安装函数，Linux对不可靠信号做了改进，在信号处理完毕后不必再重新调用该信号的安装函数；(2)信号可能丢失
>> - 可靠信号：把信号值大于SIGRTMIN小于SIGRTMAX的信号叫做可靠信号，可靠信号克服了信号丢失问题，并且支持排队功能
>
> 实时信号
>> - 非实时信号， 即不可靠信号，不支持信号排队
>> - 实时信号， 即可靠信号，支持信号排队

> 信号的处理：
> - 忽略信号(SIG_IGN)，即不做任何操作，SIGKILL和SIGSTOP两个信号是不能忽略、不能阻塞也不能捕获
> - 捕捉信号，定义信号处理函数
> - 执行缺省操作(SIG_DFL)

> 一个进程可以使用`signal`和`sigaction`修改信号的处理方式，默认的信号操作有下面五类，
> - Term: 终止进程
> - Ign: 忽略信号
> - Core: 终止进程然后产生core文件
> - Stop: 停止进程
> - Cont: 如果进程是暂停的就让进程继续允许

> SIGKILL和SIGSTOP既不能被捕获也不能忽略

**函数列表**
- `sighandler_t signal(int signum, sighandler_t handler);`
  > `#include <signal.h>`
  >
  > 描述：将信号值为signum的信号的处理配置为handler, signal在不同Unix版本以及在不同Linux版本中都有区别，推荐使用sigaction，在handler运行期间，系统自动屏蔽该信号；SIGKILL和SIGSTOP既不能被捕获也不能被忽略，为这两个信号安装安装自定义处理函数时会报错；
  >
  > signum: 指定信号值
  >
  > handler: 指定信号处理方式，SIG_IGN-对信号忽略，SIG_DFL-使用默认处理方式，函数(int signo)-使用函数处理信号，注意SIGKILL和SIGSTOP既不能被捕获也不能忽略
  >
  > 返回：成功-返回之前信号处理处理器的方式sighandler_t；失败-返回SIG_ERR并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/signal.2.html)

- `int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact);`
  > `#include <signal.h>`
  >
  > 描述：安装信号处理函数，在handler运行期间，系统自动屏蔽该信号；SIGKILL和SIGSTOP既不能被捕获也不能被忽略，为这两个信号安装安装自定义处理函数时会报错；
  >
  > signum: 指定信号值
  >
  > act: 用于指定信号的处理方式
  >
  > oddact: 用于输出之前的信号处理方式，即保存旧的信号处理方式
  >
  > 返回：成功-返回0；失败-返回-1，并设置errno
  >
  > man 7 [参考](https://www.itread01.com/content/1509698423.html)
  >
  > note: 信号处理函数应该是异步信号安全函数的调用([async-signal-sage](http://man7.org/linux/man-pages/man7/signal-safety.7.html)), 当信号处理程序操作干扰正在被中断的操作时，就会引发异步信号安全问题
```C
struct sigaction {
        void     (*sa_handler)(int);
        void     (*sa_sigaction)(int, siginfo_t *, void *);
        sigset_t   sa_mask;
        int        sa_flags;
        void     (*sa_restorer)(void);
};
/**
上述结构体的一些注意点：
1.sa_handler和sa_sigaction只能有一个被设置，sa_handler只有一个signo的参数，而sa_sigaction有三个参数，也可以为SIG_DFL使用默认处理方式、SIG_IGN忽略信号；
2.sa_mask用来指定在处理信号函数的时暂时的信号掩码，一般正在被处理的信号会被忽略, sigemptyset(&sigaction.sa_mask); sigaddset(&sigaction.sa_mask, SIGTERM);
3.sa_flag
  > - SA_RESTART: 被信号打断的系统调用会被自动重启
  > - SA_NOCLDSTOP: 使父进程在子进程暂停或继续运行时不会收到SIGCHLD信号
  > - SA_NOCLDWAIT: 使父进程在子进程退出时不会收到SIGCHLD信号，这时子进程退出也不会称为僵尸进程
  > - SA_NODEFFER: 信号处理函数执行期间任能发出这个信号
  > - SA_SIGINFO: 使用sa_sigaction成员而不是sa_handler作为信号处理函数
4.sa_restorer: 已经废弃，不再使用
**/

void handler(int sig, siginfo_t *info, void *ucontext){
        ...
}

siginfo_t {
        int      si_signo;     /* 信号值 */
        int      si_errno;     /* errno的值 */
        int      si_code;      /* Signal code */
        int      si_trapno;    /* Trap number that caused
                                         hardware-generated signal
                                         (unused on most architectures) */
        pid_t    si_pid;       /* 适用SIGCHLD，代表被终止的进程ID */
        uid_t    si_uid;       /* 适用SIGCHLD，代表被终止进程的UID*/
        int      si_status;    /* 适用SIGCHLD，代表被终止进程的状态 */
        clock_t  si_utime;     /* 适用SIGCHLD，代表被终止进程消耗的用户时间 */
        clock_t  si_stime;     /* 适用SIGCHLD，代表被终止进程消耗的系统时间 */
        sigval_t si_value;     /* Signal value */
        int      si_int;       /* POSIX.1b signal */
        void    *si_ptr;       /* POSIX.1b signal */
        int      si_overrun;   /* Timer overrun count;
                                POSIX.1b timers */
        int      si_timerid;   /* Timer ID; POSIX.1b timers */
        void    *si_addr;      /* 导致进程出错的时的内存地址 */
        long     si_band;      /* Band event (was int in
                                 glibc 2.3.2 and earlier) */
        int      si_fd;        /* File descriptor */
        short    si_addr_lsb;  /* Least significant bit of address
                                (since Linux 2.6.32) */
        void    *si_lower;     /* Lower bound when address violation
                                occurred (since Linux 3.19) */
        void    *si_upper;     /* Upper bound when address violation
                                occurred (since Linux 3.19) */
        int      si_pkey;      /* Protection key on PTE that caused
                                fault (since Linux 4.6) */
        void    *si_call_addr; /* Address of system call instruction
                                (since Linux 3.5) */
        int      si_syscall;   /* Number of attempted system call
                                (since Linux 3.5) */
        unsigned int si_arch;  /* Architecture of attempted system call
                                (since Linux 3.5) */
}
```

> 信号发送函数：
- `int raise(int sig);`
  > `#include <signal.h>`
  >
  > 描述：发送一个信号给调用该函数的进程或线程
  >
  > sig: 指定发送的信号
  >
  > 返回：成功-返回0；失败-返回非0
  >
  > note: 该函数相当于单线程的`kill(getpid(), sig);`或多线程的`pthread_kill(pthread_self(), sig)`
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man3/raise.3.html)

- `int kill(pid_t pid, int sig);`
  > `#include <sys/types.h>`
  >
  > `#include <signal.h>`
  >
  > 描述：向任何进程或进程组发送信号
  >
  > pid: 指定进程或进程组；pid > 0时，则发送信号到进程号为pid的进程；pid = 0，不发送信号，可用来检测指定的进程或进程组是否存在以及是否有权限向其发送信号；pid = -1，信号会发送给所有除了init的有权限的进程，不包括自己；pid < -1，发送给进程组为-pid内的所有进程
  >
  > sig: 指定发送的信号 
  >
  > 返回：成功-返回0；失败-返回-1，并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/kill.2.html)

- `int killpg(int pgrp, int sig);`
  > `#include <signal.h>`
  >
  > 描述：向进程组发送信号
  >
  > pgrp: 指定进程组id
  >
  > sig: 指定发送的信号
  >
  > 返回：成功-返回0；失败-返回-1，并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man3/killpg.3.html)

- `int pthread_kill(pthread_t thread, int sig);`
  > `#include <signal.h>`
  >
  > 描述：给线程发送一个信号
  >
  > thread: 指定线程标识符
  >
  > sig: 指定发送的信号
  >
  > 返回：成功-返回0；失败-返回错误码
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man3/pthread_kill.3.html)

- `int tkill(int tid, int sig);`
  > note: 没有函数库，需要使用`syscall`进行系统调用，另外线程ID可能被反复使用，此时发送的信号可能会被其他线程接收导致出错，所以应避免使用该函数
  >
  > 描述：向指定的线程发送信号
  >
  > tid: 指定线程ID
  >
  > sig: 指定发送的信号
  >
  > 返回：成功-返回0；失败-返回-1，并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/tgkill.2.html)

- `int tgkill(int tgid, int tid, int sig);`
  > note: 没有函数库，需要使用`syscall`进行系统调用
  >
  > 描述：向指定线程组中的线程发送信号
  >
  > tgid: 指定线程组
  >
  > tid: 指定线程id
  >
  > sig: 指定发送的线程
  >
  > 返回：成功-返回0；失败-返回-1
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/tgkill.2.html)

- `int sigqueue(pid_t pid, int sig, const union sigval value);`
  > `#include <signal.h>`
  >
  > 描述： 发送实时信号(可靠信号)和数据到指定的进程
  >
  > pid: 指定经曾id
  >
  > sig: 指定发送的信号
  >
  > value: 指定信号一起携带的数据
  >
  > 返回：成功-返回0；失败-返回-1，并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man3/sigqueue.3.html)
```C
union sigval {
        int   sival_int;
        void *sival_ptr;
};
```

- `int pause(void);`
  > `#include <unistd.h>`
  >
  > 描述：调用该函数的进程阻塞等待信号被捕获或程序被终止
  >
  > 返回：pause只有当型号被捕获并执完信号处理函数后返回，只返回-1，并设置errno为EINTR
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/pause.2.html)

- `int sigsuspend(const sigset_t *mask);`
  > `#include <signal.h>`
  >
  > 描述：使用信号掩码，在发生了指定的信号集并执行信号处理函数之后，该函数才返回，如果信号中断了该函数，不返回，注意不能屏蔽SIGKILL和SIGSTOP两个信号
  >
  > mask: 指定信号掩码
  >
  > 返回：总是返回-1，并设置errno,通常为EINTR;
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/sigsuspend.2.html)

```C
[root@mon1 ~]# kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
```

#### 参考列表
- [linux系统编程之管道（一）：匿名管道（pipe)](http://www.cnblogs.com/mickole/p/3192210.html)
- [进程间通信的方式——信号、管道、消息队列、共享内存](https://www.cnblogs.com/LUO77/p/5816326.html)
- [linux中的PIPE_SIZE与PIPE_BUF，管道最大写入值问题](https://blog.csdn.net/judwenwen2009/article/details/44134415)
- [Linux中link，unlink，close，fclose详解](https://blog.csdn.net/DLUTBruceZhang/article/details/9159431)
- [【Linux】进程间通信-命名管道FIFO](https://blog.csdn.net/xiajun07061225/article/details/8471777)
- [ftok()函数深度解析](https://blog.csdn.net/u013485792/article/details/50764224)
- [Linux环境进程间通信（三）](https://www.ibm.com/developerworks/cn/linux/l-ipc/part3/index.html)
- [进程间通信（IPC）之————消息队列](https://blog.51cto.com/2627lounuo/1763161)
- [两种Linux共享内存](http://blog.jqian.net/post/linux-shm.html)
- [Linux进程间通信——使用共享内存](https://blog.csdn.net/ljianhui/article/details/10253345)
- [semop函数详解 linux/unix](https://blog.csdn.net/wbj1234566/article/details/2256626)
- [Linux--进程间通信（信号量，共享内存）（转）](https://www.cnblogs.com/forstudy/archive/2012/03/26/2413724.html)
- [c语言 - 进程间通信 Unix Domain Socket](https://www.zfl9.com/c-ipc-unix-sock.html)
- [信号（上）](https://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index1.html)
#### 案列
- pipe_demon.c
> 源码
```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main(int argc, char *argv[]){
        int pipfd[2], ret;
        pid_t cpid;
        char buf;

        if(argc < 2){
                fprintf(stderr, "Usage: %s mesg...\n", argv[0]);
                exit(EXIT_FAILURE);
        }

        //创建管道
        ret = pipe(pipfd);
        if(ret == -1){
                //perror会先输出char *参数，然后将errno对应的错误描述输出
                perror("pipe error");
                exit(EXIT_FAILURE);
        }

        //创建子进程
        cpid = fork();
        if(cpid == -1){
                perror("fork error");
                exit(EXIT_FAILURE);
        }else if(cpid == 0){
                //关闭不必要的文件描述符，pipfd[1]为写端描述符
                close(pipfd[1]);
                printf("child(%ld) write to STDOUT_FILENO\n", (long)getpid());
                //从管道每次读取一个字符
                while(read(pipfd[0], &buf, 1) > 0){
                        write(STDOUT_FILENO, &buf, 1);
                }
                //输出到标准输出
                write(STDOUT_FILENO, "\n", 1);
                //读完数据后关闭管道读端，当管道的两端描述符都关闭后，管道会自动注销
                close(pipfd[0]);
                exit(EXIT_SUCCESS);
        }else{
                //关闭不必要的文件描述符，pipefd[0]为读端描述符
                close(pipfd[0]);
                //写数据到文件描述符
                write(pipfd[1], argv[1], strlen(argv[1]));
                //写完数据后关闭管道写端
                close(pipfd[1]);
                wait(NULL);
                exit(EXIT_SUCCESS);
        }
}
```

- fifo_daemon
> talker01.c
```C
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>

#define BUF_SIZE 4096

int main(int argc, char *argv[]){
        int ret, i, fifo01fd, fifo02fd;
        char buf[BUF_SIZE];

        for(i = 0; i < BUF_SIZE; i++){
                buf[i] = 0;
        }
        ret = mkfifo("fifo01", 0777);
        if(ret != 0){
                perror("mkfifo fifo01 error");
                exit(EXIT_FAILURE);
        }
        ret = mkfifo("fifo02", 0777);
        if(ret != 0){
                perror("mkfifo fifo02 error");
                exit(EXIT_FAILURE);
        }

        fifo01fd = open("fifo01", O_WRONLY);
        if(fifo01fd == -1){
                perror("open fifo01 error");
                exit(EXIT_FAILURE);
        }
        fifo02fd = open("fifo02", O_RDONLY);
        if(fifo02fd == -1){
                perror("open fifo02 error");
                close(fifo01fd);
                exit(EXIT_FAILURE);
        }

        while(1){
                printf("echo : ");
                fgets(buf, BUF_SIZE, stdin);
                ret = write(fifo01fd, buf, strlen(buf) + 1);
                if(ret == -1){
                        perror("write error");
                        close(fifo01fd);
                        close(fifo02fd);
                        exit(EXIT_FAILURE);
                }
                ret = read(fifo02fd, buf, BUF_SIZE);
                if(ret == -1){
                        perror("read error");
                        close(fifo01fd);
                        close(fifo02fd);
                        exit(EXIT_FAILURE);
                }
                printf("reply: %s", buf);
        }

        exit(EXIT_SUCCESS);
}
```
> talker02.c
```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>

#define BUF_SIZE 1024

int main(int argc, char *argv[]){
        int ret, i, fifo01fd, fifo02fd;
        char buf[BUF_SIZE];

        for(i = 0; i < BUF_SIZE; i++){
                buf[i] = 0;
        }
        fifo01fd = open("fifo01", O_RDONLY);
        if(fifo01fd == -1){
                perror("open fifo01 error");
                exit(EXIT_FAILURE);
        }
        fifo02fd = open("fifo02", O_WRONLY);
        if(fifo02fd == -1){
                perror("open fifo02 error");
                close(fifo01fd);
                exit(EXIT_FAILURE);
        }

        while(1){
                printf("reply: ");
                ret = read(fifo01fd, buf, BUF_SIZE);
                if(ret == -1){
                        perror("read error");
                        close(fifo01fd);
                        close(fifo02fd);
                        exit(EXIT_FAILURE);
                }
                printf("%s", buf);
                printf("echo : ");
                fgets(buf, BUF_SIZE, stdin);
                ret = write(fifo02fd, buf, strlen(buf) + 1);
                if(ret == -1){
                        perror("write error");
                        close(fifo01fd);
                        close(fifo02fd);
                        exit(EXIT_FAILURE);
                }
        }

        exit(EXIT_SUCCESS);
}
```

- msg_daemon.c
```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <time.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

static void usage(char *prog_name, char *msg);
static void send_msg(int qid, int msgtype);
static void get_msg(int qid, int msgtype);

struct msgbuf {
        long mtype;
        char mtext[80];
};

int main(int argc, char *argv[]){
        int qid, opt;
        int mode = 0;
        int msgtype = 1;
        int msgkey = 1234;

        while((opt = getopt(argc, argv, "srt:k")) != -1){
                switch(opt){
                        case 's':
                                mode = 1;
                                break;
                        case 'r':
                                mode = 2;
                                break;
                        case 't':
                                msgtype = atoi(optarg);
                                if(msgtype <= 0){
                                        usage(argv[0], "-t option must be greater than 0\n");
                                }
                                break;
                        case 'k':
                                msgkey = atoi(optarg);
                                break;
                        default:
                                usage(argv[0], "Unreconized option\n");
                }
        }

        if(mode == 0){
                usage(argv[0], "must use either -s or -r option\n");
        }
        qid = msgget(msgkey, IPC_CREAT | 0666);
        if(qid == -1){
                perror("msgget error");
                exit(EXIT_FAILURE);
        }
        if(mode == 2){
                get_msg(qid, msgtype);
        }else{
                send_msg(qid, msgtype);
        }

        exit(EXIT_SUCCESS);
}

static void usage(char *prog_name, char *msg){
        if(msg != NULL){
                fputs(msg, stderr);
        }

        fprintf(stderr, "Usage : %s [options]\n", prog_name);
        fprintf(stderr, "Options are:\n");
        fprintf(stderr, "-s     send message using msgsnd()\n");
        fprintf(stderr, "-r     read message using msgrcv()\n");
        fprintf(stderr, "-t     message type (default is 1)\n");
        fprintf(stderr, "-k     message queue key (default is 1234)\n");

        exit(EXIT_FAILURE);
}


static void send_msg(int qid, int msgtype){
        struct msgbuf msg;
        time_t t;

        msg.mtype = msgtype;
        time(&t);
        snprintf(msg.mtext, sizeof(msg.mtext), "a message at %s", ctime(&t));
        if(msgsnd(qid, (void *)&msg, sizeof(msg.mtext), IPC_NOWAIT) == -1){
                perror("msgsnd error");
                exit(EXIT_FAILURE);
        }

        printf("sent :%s\n", msg.mtext);
}

static void get_msg(int qid, int msgtype){
        struct msgbuf msg;

        if(msgrcv(qid, (void *)&msg, sizeof(msg.mtext), msgtype, MSG_NOERROR | IPC_NOWAIT) == -1){
                if(errno != ENOMSG){
                        perror("msgrcv error");
                        exit(EXIT_FAILURE);
                }
                printf("No message available for msgrcv()\n");
        }else{
                printf("recv : %s\n", msg.mtext);
        }
}
```
- shm_daemon.c
```C
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <getopt.h>
#include <string.h>

typedef struct {
        char name[16];
        int age;
} people;

static void print_version_info(const char *prog_name);
static void print_help_info(const char *prog_name);

int main(int argc, char *argv[]){
        int     shm_id, i, ret, opt;
        key_t   shm_key;
        people  *p_map;
        int     mode = 0;

        if(argc < 2){
                fprintf(stderr, "option error, use option -h to get help info\n");
                exit(EXIT_FAILURE);
        }
        while((opt = getopt(argc, argv, "vwrh")) != -1){
                switch(opt){
                        case 'v':
                                print_version_info(argv[0]);
                                break;
                        case 'w':
                                mode = 1;
                                break;
                        case 'r':
                                mode = 2;
                                break;
                        case 'h':
                                print_help_info(argv[0]);
                                break;
                        case '?':
                                print_help_info(argv[0]);
                                break;
                        default:
                                print_help_info(argv[0]);
                }
        }
        if(mode == 0){
                fprintf(stderr, "-w or -r option must set\n");
                exit(EXIT_FAILURE);
        }
        shm_key = ftok(".", 0);
        if(shm_key == -1){
                perror("ftok error");
                exit(EXIT_FAILURE);
        }
        shm_id = shmget(shm_key, 4096, IPC_CREAT | 0666);
        if(shm_id == -1){
                perror("shmget error");
                exit(EXIT_FAILURE);
        }
        p_map = (people *)shmat(shm_id, NULL, 0);
        if(p_map == (void *)-1){
                perror("shmat error");
                exit(EXIT_FAILURE);
        }
        if(mode == 1){
                for(i = 0; i < 10; i++){
                        snprintf((p_map + i) -> name, sizeof((p_map + i) -> name), "name-%d", i);
                        (p_map + i) -> age = 20 + i;
                }
        }else if(mode == 2){
                for(i = 0; i < 10; i++){
                        printf("name : %s\t", (p_map + i) -> name);
                        printf("age : %d\n", (p_map + i) ->age);
                }
        }

        ret = shmdt(p_map);
        if(ret == -1){
                perror("shmdt error");
                exit(EXIT_FAILURE);
        }

        exit(EXIT_SUCCESS);
}

static void print_version_info(const char *prog_name){
        printf("%s\n", prog_name);
        printf("version 1.0.00\n");

        exit(EXIT_FAILURE);
}

static void print_help_info(const char *prog_name){
        printf("Usage: %s options\n", prog_name);
        printf("options: \n");
        printf("-w      write\n");
        printf("-r      read\n");
        printf("-h      help info\n");
        printf("?       help info\n");

        exit(EXIT_FAILURE);
}
```

- semaphore_daemon.c
```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

#define DELAY_TIME 3
union semun{
        int             val;
        struct semid_ds *buf;
        unsigned short  *array;
};

static void sem_p(int sem_id);
static void sem_v(int sem_id);
static void del_sem(int sem_id);

int main(int argc, char *argv[]){
        int             sem_id, i, ret, status;
        pid_t           pid;
        key_t           sem_key;
        union semun     sem_union;

        sem_key = ftok(".", 0);
        if(ret == -1){
                perror("ftok error");
                exit(EXIT_FAILURE);
        }
        sem_id = semget(sem_key, 1, IPC_CREAT | 0666);
        if(sem_id == -1){
                perror("semget error");
                exit(EXIT_FAILURE);
        }
        sem_union.val = 1;
        ret = semctl(sem_id, 0, SETVAL, sem_union);
        if(ret == -1){
                perror("semctl error");
                exit(EXIT_FAILURE);
        }


        pid = fork();
        if(pid  == -1){
                perror("fork error");
                exit(EXIT_FAILURE);
        }else if(pid == 0){
                sem_p(sem_id);
                printf("child running ... \n");
                sleep(DELAY_TIME);
                printf("child %d returned value: %d\n", getpid(), pid);
                sem_v(sem_id);

                exit(EXIT_SUCCESS);
        }else{
                sem_p(sem_id);
                printf("parent running ... \n");
                sleep(DELAY_TIME);
                printf("parent %d returned value: %d\n", getpid(), pid);
                sem_v(sem_id);

                ret = waitpid(pid, &status, 0);
                if(ret == -1){
                        perror("waitpid error");
                        del_sem(sem_id);
                        exit(EXIT_FAILURE);
                }
                del_sem(sem_id);

                exit(EXIT_SUCCESS);
        }
}

static void sem_p(int sem_id){
        struct sembuf sops;

        sops.sem_num = 0;
        sops.sem_op = -1;
        sops.sem_flg = SEM_UNDO;
        if(semop(sem_id, &sops, 1) == -1){
                perror("semop p error");
                exit(EXIT_FAILURE);
        }
}

static void sem_v(int sem_id){
        struct sembuf sops;

        sops.sem_num = 0;
        sops.sem_op = 1;
        sops.sem_flg = SEM_UNDO;
        if(semop(sem_id, &sops, 1) == -1){
                perror("semop v error");
                exit(EXIT_FAILURE);
        }
}

static void del_sem(int sem_id){
        int ret;
        union semun sem_union;

        ret = semctl(sem_id, 0, IPC_RMID, sem_union);
        if(ret == -1){
                perror("semctl del error");
                exit(EXIT_FAILURE);
        }

}
```

- socket_daemon.c
> server.c
```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUFSIZE 4096
#define SOCKPATH "/run/echo.sock"
#define SOCKMAXCONN 32

int     lsnsock;

static void handle_signal(int signal);

int main(int argc, char *argv[]){
        int     connsock;
        int     i, ret, cltaddr_len;
        struct  sockaddr_un     srvaddr;
        struct  sockaddr_un     cltaddr;
        int     recv_data_len;
        char    buf[BUFSIZE];

        signal(SIGINT, handle_signal);
        signal(SIGHUP, handle_signal);
        signal(SIGTERM, handle_signal);

        lsnsock = socket(AF_UNIX, SOCK_STREAM, 0);
        if(lsnsock == -1){
                perror("socket create error");
                exit(EXIT_FAILURE);
        }
        memset(&srvaddr, 0, sizeof(struct sockaddr_un));
        srvaddr.sun_family = AF_UNIX;
        unlink(SOCKPATH);
        strcpy(srvaddr.sun_path, SOCKPATH);
        ret = bind(lsnsock, (struct sockaddr*)&srvaddr, sizeof(struct sockaddr_un));
        if(ret == -1){
                perror("bind error");
                close(lsnsock);
                exit(EXIT_FAILURE);
        }
        ret = listen(lsnsock, SOCKMAXCONN);
        if(ret == -1){
                perror("bind error");
                close(lsnsock);
                exit(EXIT_FAILURE);
        }

        for(;;){
                connsock = accept(lsnsock, (struct sockaddr *)&cltaddr, &cltaddr_len);
                if(connsock == -1){
                        perror("connect error");
                        continue;
                }
                recv_data_len = recv(connsock, buf, BUFSIZE, 0);
                if(recv_data_len == -1){
                        perror("recv error");
                        close(connsock);
                        continue;
                }else{
                        printf("new mesg: %s", buf);
                }
                ret = send(connsock, buf, strlen(buf) + 1, 0);
                if(ret == -1){
                        perror("send error");
                        close(connsock);
                        continue;
                }

                close(connsock);
        }
}

static void handle_signal(int signal){
        if(signal == SIGINT){
                fprintf(stderr, "received signal: SIGINT(%d)\n", signal);
        }else if(signal == SIGHUP){
                fprintf(stderr, "received signal: SIGHUP(%d)\n", signal);
        }else if(signal == SIGTERM){
                fprintf(stderr, "received signal: SIGTERM(%d)\n", signal);
        }

        close(lsnsock);
        unlink(SOCKPATH);
        exit(EXIT_SUCCESS);
}
```
> client.c
```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUFSIZE 4096
#define SOCKPATH "/run/echo.sock"

int main(int argc, char *argv[]){
        int     connsock;
        int     ret;
        char    buf[BUFSIZE];
        struct  sockaddr_un srvaddr;

        connsock = socket(AF_UNIX, SOCK_STREAM, 0);
        if(connsock == -1){
                perror("socket create error");
                exit(EXIT_FAILURE);
        }
        memset(&srvaddr, 0, sizeof(struct sockaddr_un));
        srvaddr.sun_family = AF_UNIX;
        strcpy(srvaddr.sun_path, SOCKPATH);
        ret = connect(connsock, (struct sockaddr*)&srvaddr, sizeof(struct sockaddr_un));
        if(ret == -1){
                perror("connet error");
                close(connsock);
                exit(EXIT_FAILURE);
        }

        printf("%% ");
        if(fgets(buf, BUFSIZE, stdin) != NULL){
                ret = send(connsock, buf, strlen(buf) + 1, 0);
                if(ret == -1){
                        perror("send error");
                        close(connsock);
                        exit(EXIT_FAILURE);
                }
        }
        ret = recv(connsock, buf, BUFSIZE, 0);
        if(ret == -1){
                perror("recv error");
                close(connsock);
                exit(EXIT_FAILURE);
        }
        printf("recv: %s", buf);

        close(connsock);
        exit(EXIT_SUCCESS);
}
```

- socketpair_daemon.c
```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUF_SIZE 4096

int main(int argc, char *argv[]){
        pid_t   pid;
        int     i, ret;
        int     sv[2];
        int     psock, csock;
        char    buf[BUF_SIZE];

        pid = socketpair(AF_LOCAL, SOCK_STREAM, 0, sv);
        if(pid == -1){
                perror("socketpair error");
                exit(EXIT_FAILURE);
        }
        psock = sv[0];
        csock = sv[1];

        pid = fork();
        if(pid < 0){
                perror("fork error");
                exit(EXIT_FAILURE);
        }else if(pid > 0){
                strcpy(buf, "message from parent");
                ret = send(psock, buf, strlen(buf) + 1, 0);
                if(ret == -1){
                        perror("send error");
                        close(psock);
                        close(csock);
                        exit(EXIT_FAILURE);
                }
                ret = recv(psock, buf, BUF_SIZE, 0);
                if(ret == -1){
                        perror("recv error");
                        close(psock);
                        close(csock);
                        exit(EXIT_FAILURE);
                }
                printf("parent(%d) receive: %s\n", getpid(), buf);
                ret = waitpid(pid, NULL, 0);
                if(ret == -1){
                        perror("waitpid error");
                        exit(EXIT_FAILURE);
                }

                close(psock);
                close(csock);
                exit(EXIT_SUCCESS);
        }else if(pid == 0){
                strcpy(buf, "message from child");
                ret = send(csock, buf, strlen(buf) + 1, 0);
                if(ret == -1){
                        perror("send error");
                        close(psock);
                        close(csock);
                        exit(EXIT_FAILURE);
                }
                ret = recv(csock, buf, BUF_SIZE, 0);
                if(ret == -1){
                        perror("recv error");
                        close(psock);
                        close(csock);
                        exit(EXIT_FAILURE);
                }
                printf("child(%d) receive: %s\n", getpid(), buf);

                exit(EXIT_SUCCESS);
        }
}
```
