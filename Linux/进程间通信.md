# 进程间通信(IPC)
> **常用的通信方式**
> - 匿名管道(pipe)
> - 命名管道(fifo)
> - 消息队列(messagequeue)
> - 共享内存(sharedmemory)
> - 信号量(semaphore)
> - 套接字(socket)
> - 信号(signal)

#### 匿名管道(pipe)
> 管道是由内核管理的一个缓冲区，一般被设计成环形的数据结构，可以看成一个循环队列，这样以便管道被循环利用；管道的一端连接一个进程的输出，进程会向管道种写入信息，管道的另一端连接另一个进程的输入，它会从管道种读取信息，管道空，则读取进程阻塞等待数据被写入，管道满，则写入进程阻塞等待数据被读取；当最后一个进程关闭对它的引用时，pipe会自动撤销；可以参考[man 7](http://man7.org/linux/man-pages/man7/pipe.7.html)

> **特点**
> - 管道是半双工的，数据只能向一个方向流动，即只支持单向数据流，双方都需要通信时，需要建立起两个管道
> - 只能用于有亲属(父子进程或兄弟进程)关系的进程之间进行通信
> - 构成独立的运行于内存的文件系统(管道不是普通的文件，但相对于进程来说，管道就是一个文件)
> - 承载无格式字节流
> - 缓冲区大小受限(PIPE_BUF)
> - 无名字标识

**创建**
- `int pipe(int pipefd[2]);`
  > `#include <unistd.h>`
  >
  > 描述：创建一个管道，pipefd[0]代表读端，pipefd[1]代表写端
  >
  > pipefd: 用于保存生成的管道描述符,pipefd[0]代表读端，pipefd[1]代表写端
  >
  > 返回： 成功-返回0；失败-返回-1，并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/pipe.2.html)

- `int pipe2(int pipefd[2], int flags);`
  > `#define _GNU_SOURCE`
  >
  > `#include <fcntl.h>`
  >
  > `#include <unistd.h>`
  >
  > 描述：和`pipe`一样用于创建管道，当flags=0时和pipe函数一样；
  >
  > pipefd: 用于保存生成的管道描述符,pipefd[0]代表读端，pipefd[1]代表写端
  >
  > flags: 用于设置管道特性：
  > - 0: 不设置管道的特性，则pipe2函数和pipe函数一致
  > - O_CLOEXEC: 如果设置该标志位，则在子进程fork+exec后会原子操作该类文件描述符，和open打开文件描述符特性一致
  > - O_DIRECT: 将IO模式设置为包模式，每个write操作写入的数据都是被看作是一个独立的包，如果写入的数据的字节长度多余PIPE_BUF(`getconf -a | grep PIPE`或`ulimit -p`，linux的PIPE_BUF一般为4096 bytes)字节的数据会被自动切分成多个包发送，PIPE_BUF和写入字节会影响阻塞情况下write的原子操作特性；并且read操作设置该属性后一次读取一个包，读取的size小于包的大小会读取size个字节，包中多余的数据字节将会被丢弃，所以一般将read的size设置为PIPE_BUF，这样就保证能够都去出完整的一个包数据；
  > - O_NONBLOCK: 设置该管道符的操作为非阻塞模式，默认为阻塞模式
  >
  > 返回： 成功-返回0；失败-返回-1，并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/pipe.2.html)

#### 命名管道(FIFO)
> 匿名管道没有名字，只能在亲缘进程间通信；而有名管道就是为了克服这个缺点，有名在系统上提供了一个路径名，以文件形式存在于系统中，这样，即使于有名管道的创建进程不存在的亲缘关系的进程，只要可以访问该文件，就能够彼此通信；有名管道严格遵循先进先出的规则，对它的读总是从开始处返回数据，对它的写则是把数据添加到末尾，有名管道不支持lseek等文件定位操作；虽然有名管道已文件形式存在系统中，但写入其的内容存储在内存中，不占用任何的磁盘空间，操作的时候也需要两段同时操作，否则默认就阻塞；参考[这里](http://man7.org/linux/man-pages/man7/fifo.7.html)

> **特点**
> - 单向数据流，半双工模式，同时需要通信时需要创建两个有名管道
> - 以文件形式出现中系统中
> - 内容存储在内存中，不占用磁盘空间
> - 命名管道会一直存在，需要显示地删除
> - 写入原子操作受限(PIPE_BUF)，缓冲区受限
> - 系统内的进程间通信，可以不是有亲属关系的进程

**创建**
- `int mkfifo(const char *pathname, mode_t mode);`
  > `#include <sys/types.h>`
  >
  > `#include <sys/stat.h>`
  >
  > 描述：创建具有指定权限的命名管道，创建成功就可以调用open,read,write,close等函数对命名管道进行操作了；
  >
  > pathname: 管道的文件路径名称
  >
  > mode: 命名管道的权限，会受到进程umask的影响，最终的权限为mode & ~umask, mode可以参考[这里](http://man7.org/linux/man-pages/man2/open.2.html)的O_CREAT部分中的权限，也可以传入`0755`等参数
  >
  > 返回：成功-返回0；失败-返回-1，并设置了errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man3/mkfifo.3.html)

- `int mkfifoat(int dirfd, const char *pathname, mode_t mode);`
  > `#include <fcntl.h>`
  >
  > `#include <sys/stat.h>`
  >
  > 描述：和`mkfifo`函数一样，用于创建一个命名管道，当pathname是绝对路径时，忽略dirfd参数，当pathname时相对路径时，则创建的的命名管道路径不是相对于进程的当前目录，而是相对于dirfd文件描述符，如果dirfd=AT_FDCWD，那么是相对于进程当前目录的；
  >
  > dirfd: 指定用于创建命名管道的描述符
  >
  > pathname: 命名管道路径名
  >
  > mode: 命名管道的权限
  >
  > 返回：成功-返回0；失败-返回-1，并设置了errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man3/mkfifo.3.html)

- `int unlink(const char *pathname);`
  > `#include <unistd.h>`
  >
  > 描述：从文件系统中删除一个名字，如果这个名字是指向文件的最后以连接，并且没有进程打开这个文件时，则删除文件，如果有进程打开文件，则在文件关闭后删除这个文件，释放文件所占用的空间；如果pathname是一个符号连接，则删除连接；可以使用该函数来删除命名管道
  >
  > pathname: 指定要删除的名字
  >
  > 返回：成功-返回0；失败-返回-1并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/unlink.2.html)

- `int unlinkat(int dirfd, const char *pathname, int flags);`
  > `#include <fcntl.h>`
  >
  > `#include <unistd.h>`
  >
  > 描述：和`unlink`函数一样，用于删除文件系统中的一个名字；如果pathname是绝对路径，则忽略dirfd;如果pathname是相对路径，则pathname是相对于dirfd的，而不是先对于进程的当前目录；
  >
  > dirfd: 指定相对路径描述符
  >
  > pathname: 指定要删除的文件描述符
  >
  > flags: 默认为0，如果设置为AT_REMOVEDIR时，表示删除一个目录，相当于rmdir
  >
  > 返回：成功-返回0；失败-返回-1并设置errno;
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/unlink.2.html)

#### 消息队列
> 消息队列就是一个消息的链表，用户可以向队列中添加信息，也可以从队列中读取消息，每个消息有特定的类型，接收时可以不按顺序接收，也可以根据自定义条件接收特定类型的消息；

> **特点**
> - 基于消息，而管道时基于字节流
> - 用链表实现
> - 每个消息有固定大小，消息大小字节上限为msgmax(`cat /proc/sys/kernel/msgmax`)，队列的最大字节数msgmnb(`cat /proc/sys/kernel/msgmnb`),系统队列上限msgmni(`cat /proc/sys/kernel/msgmni`)

**创建**
- `key_t ftok(const char *pathname, int proj_id);`
  > `#include <sys/types.h>`
  >
  > `#include <sys/ipc.h>`
  >
  > 描述：用指定的文件名称和8位的整形proj_id生成IPC key,所以proj_id的取值范围位1到255，可以用于`msgget`,`semget`和`shmget`函数中
  >
  > pathname: 可以任意指定，不存在权限问题，但是该文件或目录必须存在，ftok会使用到该文件的inode来取一个值
  >
  > proj_id: 可以自己约定，随意取值，在1到255之间
  >
  > 返回：成功-返回key_t;失败-返回-1，并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man3/ftok.3.html)
  >
  > note: 注意key_t用来唯一的表示一个消息队列、信号量或共享内存，相同的pathname和proj_id会得到相同的key_t，但是必须保证多次使用的时候pathname的inode要一致，删除后重新创建的pathname会使得其inode发送变化，所以生成的key_t不一致，所以应当注意；

- `int msgget(key_t key, int msgflg);`
  > `#include <sys/types.h>`
  >
  > `#include <sys/ipc.h>`
  >
  > `#include <sys/msg.h>`
  >
  > 描述：用于生成一个消息队列
  >
  > key: 调用ftok函数生成的IPC key，用于唯一标识一个消息队列
  >
  > msgflag: IPC_CREATE-如果消息队列存在，则返回已经存在的消息队列标识符，如果消息队列不存在，则新创建一个消息都列；IPC_CREATE|IPC_EXCL-消息队列不存在时就创建，存在时返回-1，并设置errno
  >
  > 返回：成功-返回消息队列标识符；失败-返回-1，并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/msgget.2.html)

- `int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);`
  > `#include <sys/types.h>`
  >
  > `#include <sys/ipc.h>`
  >
  > `#include <sys/msg.h>`
  >
  > 描述：添加消息到消息队列中
  >
  > msqid: 指定的消息队列id
  >
  > msgp: 指向消息队列的一个缓冲区，用来存储发送的消息，是一个用户可定义的结构体，如struct msgbuf
  >
  > msgsz: 指定消息的字节大小
  >
  > msgflg: 发送属性设置，常用的标志位为IPC_NOWAIT-设置该位时，如果没有足够的空间添加一个消息，则立即返回而不是阻塞，错误码为EAGAIN
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/msgrcv.2.html)
```C
struct msgbuf {
        long mtype;       /* 消息队列的类型，必须大于0 */
        char mtext[msgsz];    /* 消息队列的数据，是一个字符串数组， 数据大小由msgsz指定*/
};
  ```

- `ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg);`
  > `#include <sys/types.h>`
  >
  > `#include <sys/ipc.h>`
  >
  > `#include <sys/msg.h>`
  >
  > 描述：从消息队列中读取消息
  >
  > msgid: 从指定的消息队列中接收消息
  >
  > msgp: 用来存储接收的消息
  >
  > msgsz: 指定接收消息的大小
  >
  > msgtyp: 指定接收消息的类型，不是该类型的消息会被过滤
  >
  > msgflag: 接收属性配置；IPC_NOWAIT-当消息队列中没有消息时立即返回，errno设置为ENOMSG；MSG_EXCEPT-返回队列中第一个类型不为msgtype的消息；MSG_NOERROR-大于msgsz的消息会被截断，多余的数据会被丢弃
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/msgrcv.2.html)

- `int msgctl(int msqid, int cmd, struct msqid_ds *buf);`
  > `#include <sys/types.h>`
  >
  > `#include <sys/ipc.h>`
  >
  > `#include <sys/msg.h>`
  >
  > 描述：该命令用于操作消息队列
  >
  > msgid: 指定消息队列的id
  >
  > cmd: 指定操作码;`IPC_STAT`-获取消息队列的信息到buf中，`IPC_SET`-通过buf中的值设置消息队列的信息，`IPC_RMID`-立即删除所有消息队列，唤醒所有读写进程，忽略第三个参数，`IPC_INFO`-返回系统队列的所有限制信息到buf中，其结构体为`struct msginfo`,`MSG_INFO`-像IPC_INFO一样返回msginfo结构体，`MSG_STAT`-和IPC_STAT结构体一样，`MSG_STAT_ANY`-和MSG_STAT操作一样，只是不做msg_perm.mode的权限检查(`ls /proc/sysvipc/msg`)，
  >
  > buf: 存储或获取消息属性
  >
  > 返回：成功-IPC_STAT,IPC_SET,IPC_RMID返回0，IPC_INFO或MSG_INFO返回内核数组中使用最多的条目的索引，MSG_STAT和MSG_STAT_ANY操作返回给定的消息队列msqid的标识；失败-返回-1,并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/msgctl.2.html)
```C
struct msqid_ds {
        struct ipc_perm msg_perm;     /* Ownership and permissions */
        time_t          msg_stime;    /* Time of last msgsnd(2) */
        time_t          msg_rtime;    /* Time of last msgrcv(2) */
        time_t          msg_ctime;    /* Time of last change */
        unsigned long   __msg_cbytes; /* Current number of bytes in
                                                queue (nonstandard) */
        msgqnum_t       msg_qnum;     /* Current number of messages
                                                in queue */
        msglen_t        msg_qbytes;   /* Maximum number of bytes
                                                allowed in queue */
        pid_t           msg_lspid;    /* PID of last msgsnd(2) */
        pid_t           msg_lrpid;    /* PID of last msgrcv(2) */
};

struct ipc_perm {
        key_t          __key;       /* Key supplied to msgget(2) */
        uid_t          uid;         /* Effective UID of owner */
        gid_t          gid;         /* Effective GID of owner */
        uid_t          cuid;        /* Effective UID of creator */
        gid_t          cgid;        /* Effective GID of creator */
        unsigned short mode;        /* Permissions */
        unsigned short __seq;       /* Sequence number */
};

struct msginfo {
        int msgpool; /* Size in kibibytes of buffer pool
                        used to hold message data;
                        unused within kernel */
        int msgmap;  /* Maximum number of entries in message
                        map; unused within kernel */
        int msgmax;  /* Maximum number of bytes that can be
                        written in a single message */
        int msgmnb;  /* Maximum number of bytes that can be
                        written to queue; used to initialize
                        msg_qbytes during queue creation
                        (msgget(2)) */
        int msgmni;  /* Maximum number of message queues */
        int msgssz;  /* Message segment size;
                        unused within kernel */
        int msgtql;  /* Maximum number of messages on all queues
                        in system; unused within kernel */
        unsigned short int msgseg;/* Maximum number of segments;
                                unused within kernel */
};
 ```

#### 共享内存
> 共享内存时允许多个不相关的进程访问同一个给定的存储区，这块存储区被两个或两个以上的进程映射到自身的地址空间中，进程之间可以对共享的内存做读写操作来实现进程间通信，它是最有效率的进程间通信方式，因为只需要数据拷贝两次就实现了通信，另外，共享内存不提供同步机制，所以一般对共享内存的使用一般结合其他同步机制如信号量一起使用，另外锁变量机制存在原子性问题，不推荐使用；有两种方式实现共享内存：
> - 内存映射：通过mmap系统调用映射一个普通文件实现内存共享，进程就像读写内存一样对普通文件进行操作，不必调用read()，write()等操作
> - 共享内存机制：通过映射特殊文件系统shm中的文件实现进程间的共享内存通信
>
> 提供了两种接口
> - POSIX共享内存(shm_open(), shm_unlink())
> - System V共享内存(shmget(), shmat(), shmdt())

> **特点**
> - 效率高，值进行两次的数据拷贝
> - 需要额外的同步互斥机制

**函数列表**
- `int shmget(key_t key, size_t size, int shmflg);` 
  > `#include <sys/ipc.h>`
  >
  > `#include <sys/shm.h>`
  >
  > 描述：创建或获取共享内存
  >
  > key: 由ftok函数提供一个key_t给shmget有效地给共享内存命名
  >
  > size: 以字节为单位指定共享内存的容量
  >
  > shmflag: 权限标志，可以使用IP_CREAT和mode参数按位或，这样共享内存不存在的时候就可以直接创建；IPC_EXEL-确定共享内存是创建的，如果已经存在，则报错；SHM_HUGETLB-指定在分配共享内存的时候使用大页；SHM_HUGE_2MB,SHM_HUGE_1GB-指定分配的大页大小为2MB或1GB，和SHM_HUGETLB一起使用；SHM_NORESERVE-不为共享内存保留交换空间(?)
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/shmget.2.html)

- `void *shmat(int shmid, const void *shmaddr, int shmflg);`
  > `#include <sys/types.h>`
  >
  > `#include <sys/shm.h>`
  >
  > 描述：将共享内存链接到当前进程的地址空间来启动对共享内存的访问
  >
  > shmid: shmget函数的返回值，标识共享内存
  >
  > shaddr: 一般为NULL，表示由系统自动进行地址的选择
  >
  > shmflag: 通常为0；`SHM_RND`-如果shmaddr被提供了，则连接的地址向下舍入到SHMLBA的倍数；`SHM_EXEC`-允许共享内存内的内容被执行；`SHM_RDONLY`-对共享内存由只读的权限；`SHM_REMAP`-从shmaddr开始拥有共享内存大小空间的需要被重新映射；
  >
  > 返回：成功-返回连接共享内存的指针；失败-返回((void *)-1)，并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/shmat.2.html)

- `int shmdt(const void *shmaddr);`
  > `#include <sys/types.h>`
  >
  > `#include <sys/shm.h>`
  >
  > 描述：取消共享内存和当前进程地址的连接
  >
  > shmaddr: 为shmat返回的地址
  >
  > 返回：成功-返回0；失败-返回-1，并设置errno
  >
  > man 7 [参考](http://man7.org/linux/man-pages/man2/shmat.2.html)

- `int shmctl(int shmid, int cmd, struct shmid_ds *buf);`
   > `#include <sys/types.h>`
   >
   > `#include <sys/shm.h>`
   >
   > 描述：控制共享内存
   >
   > shmid: 指定共享内存
   >
   > cmd: 指定对共享内存的操作；`IPC_STAT`-将内核中的共享内存数据结构信息复制到buf中；`IPC_SET`-将buf中的共享内存属性写到内核中去，用于修改共享内存属性；`IPC_RMID`-删除共享内存，忽略第三个参数；`IPC_INFO`-获取系统层面的共享内存限制信息到`struct shminfo`中;`SHM_INFO`-获取共享内存消耗的系统资源信息保存到结构体`struct shm_info`中；`SHM_STAT`,`SHM_STAT_ANY`,`SHM_LOCK`,`SHM_UNLOCK `
   >
   > buf：用于设置或获取共享内存的信息
   >
   > 返回：成功-返回0；失败-返回-1，并设置errno
   >
   > man 7 [参考](http://man7.org/linux/man-pages/man2/shmctl.2.html)
```C
struct shmid_ds {
        struct ipc_perm shm_perm;    /* Ownership and permissions */
        size_t          shm_segsz;   /* Size of segment (bytes) */
        time_t          shm_atime;   /* Last attach time */
        time_t          shm_dtime;   /* Last detach time */
        time_t          shm_ctime;   /* Last change time */
        pid_t           shm_cpid;    /* PID of creator */
        pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */
        shmatt_t        shm_nattch;  /* No. of current attaches */
        ...
};
struct ipc_perm {
        key_t          __key;    /* Key supplied to shmget(2) */
        uid_t          uid;      /* Effective UID of owner */
        gid_t          gid;      /* Effective GID of owner */
        uid_t          cuid;     /* Effective UID of creator */
        gid_t          cgid;     /* Effective GID of creator */
        unsigned short mode;     /* Permissions + SHM_DEST and
                                           SHM_LOCKED flags */
        unsigned short __seq;    /* Sequence number */
};
struct shminfo {
        unsigned long shmmax; /* Maximum segment size */
        unsigned long shmmin; /* Minimum segment size;
                                always 1 */
        unsigned long shmmni; /* Maximum number of segments */
        unsigned long shmseg; /* Maximum number of segments
                                that a process can attach;
                                unused within kernel */
        unsigned long shmall; /* Maximum number of pages of
                                shared memory, system-wide */
};
struct shm_info {
        int           used_ids; /* # of currently existing segments */
        unsigned long shm_tot;  /* Total number of shared memory pages */
        unsigned long shm_rss;  /* # of resident shared memory pages */
        unsigned long shm_swp;  /* # of swapped shared memory pages */
        unsigned long swap_attempts;  /* Unused since Linux 2.4 */
        unsigned long swap_successes;  /* Unused since Linux 2.4 */
};
```

#### 参考列表
- [linux系统编程之管道（一）：匿名管道（pipe)](http://www.cnblogs.com/mickole/p/3192210.html)
- [进程间通信的方式——信号、管道、消息队列、共享内存](https://www.cnblogs.com/LUO77/p/5816326.html)
- [linux中的PIPE_SIZE与PIPE_BUF，管道最大写入值问题](https://blog.csdn.net/judwenwen2009/article/details/44134415)
- [Linux中link，unlink，close，fclose详解](https://blog.csdn.net/DLUTBruceZhang/article/details/9159431)
- [【Linux】进程间通信-命名管道FIFO](https://blog.csdn.net/xiajun07061225/article/details/8471777)
- [ftok()函数深度解析](https://blog.csdn.net/u013485792/article/details/50764224)
- [Linux环境进程间通信（三）](https://www.ibm.com/developerworks/cn/linux/l-ipc/part3/index.html)
- [进程间通信（IPC）之————消息队列](https://blog.51cto.com/2627lounuo/1763161)
- [两种Linux共享内存](http://blog.jqian.net/post/linux-shm.html)

#### 案列
- pipe_demon.c
> 源码
```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main(int argc, char *argv[]){
        int pipfd[2], ret;
        pid_t cpid;
        char buf;

        if(argc < 2){
                fprintf(stderr, "Usage: %s mesg...\n", argv[0]);
                exit(EXIT_FAILURE);
        }

        //创建管道
        ret = pipe(pipfd);
        if(ret == -1){
                //perror会先输出char *参数，然后将errno对应的错误描述输出
                perror("pipe error");
                exit(EXIT_FAILURE);
        }

        //创建子进程
        cpid = fork();
        if(cpid == -1){
                perror("fork error");
                exit(EXIT_FAILURE);
        }else if(cpid == 0){
                //关闭不必要的文件描述符，pipfd[1]为写端描述符
                close(pipfd[1]);
                printf("child(%ld) write to STDOUT_FILENO\n", (long)getpid());
                //从管道每次读取一个字符
                while(read(pipfd[0], &buf, 1) > 0){
                        write(STDOUT_FILENO, &buf, 1);
                }
                //输出到标准输出
                write(STDOUT_FILENO, "\n", 1);
                //读完数据后关闭管道读端，当管道的两端描述符都关闭后，管道会自动注销
                close(pipfd[0]);
                exit(EXIT_SUCCESS);
        }else{
                //关闭不必要的文件描述符，pipefd[0]为读端描述符
                close(pipfd[0]);
                //写数据到文件描述符
                write(pipfd[1], argv[1], strlen(argv[1]));
                //写完数据后关闭管道写端
                close(pipfd[1]);
                wait(NULL);
                exit(EXIT_SUCCESS);
        }
}
```

- fifo_daemon
> talker01.c
```C
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>

#define BUF_SIZE 4096

int main(int argc, char *argv[]){
        int ret, i, fifo01fd, fifo02fd;
        char buf[BUF_SIZE];

        for(i = 0; i < BUF_SIZE; i++){
                buf[i] = 0;
        }
        ret = mkfifo("fifo01", 0777);
        if(ret != 0){
                perror("mkfifo fifo01 error");
                exit(EXIT_FAILURE);
        }
        ret = mkfifo("fifo02", 0777);
        if(ret != 0){
                perror("mkfifo fifo02 error");
                exit(EXIT_FAILURE);
        }

        fifo01fd = open("fifo01", O_WRONLY);
        if(fifo01fd == -1){
                perror("open fifo01 error");
                exit(EXIT_FAILURE);
        }
        fifo02fd = open("fifo02", O_RDONLY);
        if(fifo02fd == -1){
                perror("open fifo02 error");
                close(fifo01fd);
                exit(EXIT_FAILURE);
        }

        while(1){
                printf("echo : ");
                fgets(buf, BUF_SIZE, stdin);
                ret = write(fifo01fd, buf, strlen(buf) + 1);
                if(ret == -1){
                        perror("write error");
                        close(fifo01fd);
                        close(fifo02fd);
                        exit(EXIT_FAILURE);
                }
                ret = read(fifo02fd, buf, BUF_SIZE);
                if(ret == -1){
                        perror("read error");
                        close(fifo01fd);
                        close(fifo02fd);
                        exit(EXIT_FAILURE);
                }
                printf("reply: %s", buf);
        }

        exit(EXIT_SUCCESS);
}
```
> talker02.c
```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>

#define BUF_SIZE 1024

int main(int argc, char *argv[]){
        int ret, i, fifo01fd, fifo02fd;
        char buf[BUF_SIZE];

        for(i = 0; i < BUF_SIZE; i++){
                buf[i] = 0;
        }
        fifo01fd = open("fifo01", O_RDONLY);
        if(fifo01fd == -1){
                perror("open fifo01 error");
                exit(EXIT_FAILURE);
        }
        fifo02fd = open("fifo02", O_WRONLY);
        if(fifo02fd == -1){
                perror("open fifo02 error");
                close(fifo01fd);
                exit(EXIT_FAILURE);
        }

        while(1){
                printf("reply: ");
                ret = read(fifo01fd, buf, BUF_SIZE);
                if(ret == -1){
                        perror("read error");
                        close(fifo01fd);
                        close(fifo02fd);
                        exit(EXIT_FAILURE);
                }
                printf("%s", buf);
                printf("echo : ");
                fgets(buf, BUF_SIZE, stdin);
                ret = write(fifo02fd, buf, strlen(buf) + 1);
                if(ret == -1){
                        perror("write error");
                        close(fifo01fd);
                        close(fifo02fd);
                        exit(EXIT_FAILURE);
                }
        }

        exit(EXIT_SUCCESS);
}
```

- msg_daemon.c
```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <time.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>

static void usage(char *prog_name, char *msg);
static void send_msg(int qid, int msgtype);
static void get_msg(int qid, int msgtype);

struct msgbuf {
        long mtype;
        char mtext[80];
};

int main(int argc, char *argv[]){
        int qid, opt;
        int mode = 0;
        int msgtype = 1;
        int msgkey = 1234;

        while((opt = getopt(argc, argv, "srt:k")) != -1){
                switch(opt){
                        case 's':
                                mode = 1;
                                break;
                        case 'r':
                                mode = 2;
                                break;
                        case 't':
                                msgtype = atoi(optarg);
                                if(msgtype <= 0){
                                        usage(argv[0], "-t option must be greater than 0\n");
                                }
                                break;
                        case 'k':
                                msgkey = atoi(optarg);
                                break;
                        default:
                                usage(argv[0], "Unreconized option\n");
                }
        }

        if(mode == 0){
                usage(argv[0], "must use either -s or -r option\n");
        }
        qid = msgget(msgkey, IPC_CREAT | 0666);
        if(qid == -1){
                perror("msgget error");
                exit(EXIT_FAILURE);
        }
        if(mode == 2){
                get_msg(qid, msgtype);
        }else{
                send_msg(qid, msgtype);
        }

        exit(EXIT_SUCCESS);
}

static void usage(char *prog_name, char *msg){
        if(msg != NULL){
                fputs(msg, stderr);
        }

        fprintf(stderr, "Usage : %s [options]\n", prog_name);
        fprintf(stderr, "Options are:\n");
        fprintf(stderr, "-s     send message using msgsnd()\n");
        fprintf(stderr, "-r     read message using msgrcv()\n");
        fprintf(stderr, "-t     message type (default is 1)\n");
        fprintf(stderr, "-k     message queue key (default is 1234)\n");

        exit(EXIT_FAILURE);
}


static void send_msg(int qid, int msgtype){
        struct msgbuf msg;
        time_t t;

        msg.mtype = msgtype;
        time(&t);
        snprintf(msg.mtext, sizeof(msg.mtext), "a message at %s", ctime(&t));
        if(msgsnd(qid, (void *)&msg, sizeof(msg.mtext), IPC_NOWAIT) == -1){
                perror("msgsnd error");
                exit(EXIT_FAILURE);
        }

        printf("sent :%s\n", msg.mtext);
}

static void get_msg(int qid, int msgtype){
        struct msgbuf msg;

        if(msgrcv(qid, (void *)&msg, sizeof(msg.mtext), msgtype, MSG_NOERROR | IPC_NOWAIT) == -1){
                if(errno != ENOMSG){
                        perror("msgrcv error");
                        exit(EXIT_FAILURE);
                }
                printf("No message available for msgrcv()\n");
        }else{
                printf("recv : %s\n", msg.mtext);
        }
}
```

