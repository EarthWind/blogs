# 类和对象
> 类是一种抽象，它包含了一些属性和方法，定义了对象的特征和可进行的操作；
```C++
// 类的声明
class Box
{
    public:
        // 公有成员
        double length;   // 盒子的长度
        double breadth;  // 盒子的宽度
        double height;   // 盒子的高度
        double getLength(void){
            return length;
        }
        double setLength(double len);
        double getVolume(void);// 返回体积
    private:
        // 私有成员
    protected:
        // 受保护成员
};

double Box::setLength(double len){
    length = len;
}

double Box::getVolume(void){
    return length * breadth * height;
}

Box Box1;          // 声明 Box1对象，类型为 Box
Box Box2;          // 声明 Box2对象，类型为 Box
```
> - 公有成员在程序中类的外部是可访问的。
> - 私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。默认情况下，类的所有成员都是私有的。
> 保护成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。而私有成员不能被派生类访问；
> 类的对象的公共数据成员可以使用直接成员访问运算符 (.) 来访问。

## 构造函数
> 类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时自动执行。构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。构造函数必须是 public 属性的，不然没有对象能够调用；构造函数可以重载，调用的时候必须要匹配一个，也说明了只有一个构造函数被执行；在没有定义构造函数的情况下，编译器会默认生成一个构造函数，没有形参，函数体是空的，不执行任何操作；
> - 一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成。
> - 最后需要注意的一点是，调用没有参数的构造函数也可以省略括号。
```C++
class Line{
    public:
        Line();
    protected:
    private:
};

Line::Line(void){
    cout << "Object is being created" << endl;
}
```
> - 默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数，用于对成员便变量进行初始化
> - 使用构造函数初始化列表并没有效率上的优势，仅仅是书写方便，尤其是成员变量较多时，这种写法非常简单明了。
> - 注意，成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关。
> - 初始化 const 成员变量的唯一方法就是使用初始化列表。
```C++
C::C( double a, double b, double c): X(a), Y(b), Z(c){
  ....
}
// 类似于
C:C( double a, double b, double c){
    X = a;
    Y = b;
    Z = c;
}
``

## 析构函数
> - 类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。
> - 没有返回值，不需要程序员显式调用（程序员也没法显式调用），而是在销毁对象时自动执行。
> - new创建的对象位于堆区，通过delete删除时才会调用析构函数，如果没有delete，析构函数就不会执行
> - 析构函数没有参数，不能被重载，因此一个类就只有一个析构函数；
```C++
class Line{
    public:
        Line();
        ~Line();
    protected:
    private:
};

Line::Line(void){
    cout << "Object is being created" << endl;
}
Line::~Line(){
    cout << "Object is being deleted" << endl;
}
```

## 拷贝构造函数
> C++支持两种初始化方式：
> - 拷贝初始化：`int a = 5;`
> - 直接初始化：`int a(5);`
>
> 这两种初始化方式对其他类型没有区别，对于类类型直接初始化直接调用实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数；
```C
class Line{
    public:
        Line();                 // 构造函数
        ~Line();                // 析构函数
        Line( const Line &obj); // 拷贝构造函数
};

Line::Line(const Line &obj)
{
    cout << "调用拷贝构造函数并为指针 ptr 分配内存" << endl;
    // ...
}
```
> 以下情况都会调用拷贝构造函数：
> - 一个对象以值传递的方式传入函数体
> - 一个对象以值传递的方式从函数返回
> - 一个对象需要通过另外一个对象进行初始化。

## 友元
> 友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类；类的友元函数是定义在类外部，声明在类的内部，尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。使用friend关键字；
>
> 友元可以访问类的所有成员
```C++
class Box{
    double width;
    public:
        double length;
        friend void printWidth(Box box); // 友元函数，不是类的成员函数
        friend class ClassTwo; // 友元类，可以访问该类的所有成员
        void setWidth(double wid);
};

void printWidth(Box box){
    cout << "Width of box" << box.width << endl;
}

Box::setWidth(double wid){
    width = wid;
}
```

## 内联函数
> 如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。对内联函数进行任何修改，都需要重新编译函数的所有客户端，内联使用关键字inline;如果已定义的函数多于一行，编译器会忽略 inline 限定符。
>
> 在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。所以建议在类体内对成员函数进行声明，在类体外进行函数的定义；


## this指针
> 在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。
>
> 友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。

## 指向类的指针
> 一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 ->，就像访问指向结构的指针一样。
```C++
class Box{
    public:
        Box(double l, double b, double h);
        double Volume(){
            return length * breadth * height;
        }
    private:
        double length;
        double breadth;
        double height;
};

Box::Box(double l, double b, double h){
    cout << "Constructor called" << endl;
    length = l;
    breadth = b;
    height = h;
}

Box box1(1.0, 2.0, 3.0);
Box *ptrBox;

ptrBox = &box1;
ptrBox -> Volume();
```

## 类的静态成员
> 使用 static 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。
> 
>静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化;
```C++
class Box{
    public:
        static int objectCount;
}

// 初始化类Box的静态变量
int Box::objectCount = 0;
```

> 如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，静态函数只要使用类名加范围解析运算符 :: 就可以访问。
>
> 静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。
>
> 静态成员函数有一个类范围，他们不能访问类的 this 指针。

